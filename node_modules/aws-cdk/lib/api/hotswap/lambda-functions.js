"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
const stream_1 = require("stream");
const AWS = require("aws-sdk");
const common_1 = require("./common");
const util_1 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return [{
                hotswappable: true,
                resourceType: 'AWS::Lambda::Version',
                resourceNames: [],
                propsChanged: [],
                service: 'lambda',
                apply: async (_sdk) => { },
            }];
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return classifyAliasChanges(change);
    }
    if (change.newValue.Type !== 'AWS::Lambda::Function') {
        return [];
    }
    const ret = [];
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['Code', 'Environment', 'Description']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, change.newValue.Properties?.FunctionName);
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'lambda',
            resourceNames: [
                `Lambda Function '${functionName}'`,
                // add Version here if we're publishing a new one
                ...await renderVersions(logicalId, evaluateCfnTemplate, [`Lambda Version for Function '${functionName}'`]),
                // add any Aliases that we are hotswapping here
                ...await renderAliases(logicalId, evaluateCfnTemplate, async (alias) => `Lambda Alias '${alias}' for Function '${functionName}'`),
            ],
            apply: async (sdk) => {
                const lambdaCodeChange = await evaluateLambdaFunctionProps(classifiedChanges.hotswappableProps, change.newValue.Properties?.Runtime, evaluateCfnTemplate);
                if (lambdaCodeChange === undefined) {
                    return;
                }
                if (!functionName) {
                    return;
                }
                const { versionsReferencingFunction, aliasesNames } = await versionsAndAliases(logicalId, evaluateCfnTemplate);
                const lambda = sdk.lambda();
                const operations = [];
                if (lambdaCodeChange.code !== undefined || lambdaCodeChange.configurations !== undefined) {
                    if (lambdaCodeChange.code !== undefined) {
                        const updateFunctionCodeResponse = await lambda.updateFunctionCode({
                            FunctionName: functionName,
                            S3Bucket: lambdaCodeChange.code.s3Bucket,
                            S3Key: lambdaCodeChange.code.s3Key,
                            ImageUri: lambdaCodeChange.code.imageUri,
                            ZipFile: lambdaCodeChange.code.functionCodeZip,
                            S3ObjectVersion: lambdaCodeChange.code.s3ObjectVersion,
                        }).promise();
                        await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
                    }
                    if (lambdaCodeChange.configurations !== undefined) {
                        const updateRequest = {
                            FunctionName: functionName,
                        };
                        if (lambdaCodeChange.configurations.description !== undefined) {
                            updateRequest.Description = lambdaCodeChange.configurations.description;
                        }
                        if (lambdaCodeChange.configurations.environment !== undefined) {
                            updateRequest.Environment = lambdaCodeChange.configurations.environment;
                        }
                        const updateFunctionCodeResponse = await lambda.updateFunctionConfiguration(updateRequest).promise();
                        await waitForLambdasPropertiesUpdateToFinish(updateFunctionCodeResponse, lambda, functionName);
                    }
                    // only if the code changed is there any point in publishing a new Version
                    if (versionsReferencingFunction.length > 0) {
                        const publishVersionPromise = lambda.publishVersion({
                            FunctionName: functionName,
                        }).promise();
                        if (aliasesNames.length > 0) {
                            // we need to wait for the Version to finish publishing
                            const versionUpdate = await publishVersionPromise;
                            for (const alias of aliasesNames) {
                                operations.push(lambda.updateAlias({
                                    FunctionName: functionName,
                                    Name: alias,
                                    FunctionVersion: versionUpdate.Version,
                                }).promise());
                            }
                        }
                        else {
                            operations.push(publishVersionPromise);
                        }
                    }
                }
                // run all of our updates in parallel
                // Limited set of updates per function
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(operations);
            },
        });
    }
    return ret;
}
/**
 * Determines which changes to this Alias are hotswappable or not
 */
function classifyAliasChanges(change) {
    const ret = [];
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['FunctionVersion']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: [],
            service: 'lambda',
            resourceNames: [],
            apply: async (_sdk) => { },
        });
    }
    return ret;
}
/**
 * Evaluates the hotswappable properties of an AWS::Lambda::Function and
 * Returns a `LambdaFunctionChange` if the change is hotswappable.
 * Returns `undefined` if the change is not hotswappable.
 */
async function evaluateLambdaFunctionProps(hotswappablePropChanges, runtime, evaluateCfnTemplate) {
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let code = undefined;
    let description = undefined;
    let environment = undefined;
    for (const updatedPropName in hotswappablePropChanges) {
        const updatedProp = hotswappablePropChanges[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let s3Bucket, s3Key, s3ObjectVersion, imageUri, functionCodeZip;
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3ObjectVersion':
                            s3ObjectVersion = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ImageUri':
                            imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ZipFile':
                            // We must create a zip package containing a file with the inline code
                            const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression(runtime);
                            if (!functionRuntime) {
                                return undefined;
                            }
                            // file extension must be chosen depending on the runtime
                            const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
                            functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
                            break;
                    }
                }
                code = {
                    s3Bucket,
                    s3Key,
                    s3ObjectVersion,
                    imageUri,
                    functionCodeZip,
                };
                break;
            case 'Description':
                description = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            case 'Environment':
                environment = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue);
                break;
            default:
                // we will never get here, but just in case we do throw an error
                throw new Error('while apply()ing, found a property that cannot be hotswapped. Please report this at github.com/aws/aws-cdk/issues/new/choose');
        }
    }
    const configurations = description || environment ? { description, environment } : undefined;
    return code || configurations ? { code, configurations } : undefined;
}
/**
 * Compress a string as a file, returning a promise for the zip buffer
 * https://github.com/archiverjs/node-archiver/issues/342
 */
function zipString(fileName, rawString) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const converter = new stream_1.Writable();
        converter._write = (chunk, _, callback) => {
            buffers.push(chunk);
            process.nextTick(callback);
        };
        converter.on('finish', () => {
            resolve(Buffer.concat(buffers));
        });
        const archive = archiver('zip');
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(converter);
        archive.append(rawString, {
            name: fileName,
            date: new Date('1980-01-01T00:00:00.000Z'), // Add date to make resulting zip file deterministic
        });
        void archive.finalize();
    });
}
/**
  * After a Lambda Function is updated, it cannot be updated again until the
  * `State=Active` and the `LastUpdateStatus=Successful`.
  *
  * Depending on the configuration of the Lambda Function this could happen relatively quickly
  * or very slowly. For example, Zip based functions _not_ in a VPC can take ~1 second whereas VPC
  * or Container functions can take ~25 seconds (and 'idle' VPC functions can take minutes).
  */
async function waitForLambdasPropertiesUpdateToFinish(currentFunctionConfiguration, lambda, functionName) {
    const functionIsInVpcOrUsesDockerForCode = currentFunctionConfiguration.VpcConfig?.VpcId ||
        currentFunctionConfiguration.PackageType === 'Image';
    // if the function is deployed in a VPC or if it is a container image function
    // then the update will take much longer and we can wait longer between checks
    // otherwise, the update will be quick, so a 1-second delay is fine
    const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
    // configure a custom waiter to wait for the function update to complete
    lambda.api.waiters.updateFunctionPropertiesToFinish = {
        name: 'UpdateFunctionPropertiesToFinish',
        operation: 'getFunction',
        // equates to 1 minute for zip function not in a VPC and
        // 5 minutes for container functions or function in a VPC
        maxAttempts: 60,
        delay: delaySeconds,
        acceptors: [
            {
                matcher: 'path',
                argument: "Configuration.LastUpdateStatus == 'Successful' && Configuration.State == 'Active'",
                expected: true,
                state: 'success',
            },
            {
                matcher: 'path',
                argument: 'Configuration.LastUpdateStatus',
                expected: 'Failed',
                state: 'failure',
            },
        ],
    };
    const updateFunctionPropertiesWaiter = new AWS.ResourceWaiter(lambda, 'updateFunctionPropertiesToFinish');
    await updateFunctionPropertiesWaiter.wait({
        FunctionName: functionName,
    }).promise();
}
/**
 * Get file extension from Lambda runtime string.
 * We use this extension to create a deployment package from Lambda inline code.
 */
function determineCodeFileExtFromRuntime(runtime) {
    if (runtime.startsWith('node')) {
        return 'js';
    }
    if (runtime.startsWith('python')) {
        return 'py';
    }
    // Currently inline code only supports Node.js and Python, ignoring other runtimes.
    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#aws-properties-lambda-function-code-properties
    throw new evaluate_cloudformation_template_1.CfnEvaluationException(`runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`);
}
/**
 * Finds all Versions that reference an AWS::Lambda::Function with logical ID `logicalId`
 * and Aliases that reference those Versions.
 */
async function versionsAndAliases(logicalId, evaluateCfnTemplate) {
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId)
        .filter(r => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = (0, util_1.flatMap)(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    // Limited set of updates per function
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => evaluateCfnTemplate.evaluateCfnExpression(a.Properties?.Name)));
    return { versionsReferencingFunction, aliasesNames };
}
/**
 * Renders the string used in displaying Alias resource names that reference the specified Lambda Function
 */
async function renderAliases(logicalId, evaluateCfnTemplate, callbackfn) {
    const aliasesNames = (await versionsAndAliases(logicalId, evaluateCfnTemplate)).aliasesNames;
    // Limited set of updates per function
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(aliasesNames.map(callbackfn));
}
/**
 * Renders the string used in displaying Version resource names that reference the specified Lambda Function
 */
async function renderVersions(logicalId, evaluateCfnTemplate, versionString) {
    const versions = (await versionsAndAliases(logicalId, evaluateCfnTemplate)).versionsReferencingFunction;
    return versions.length > 0 ? versionString : [];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFXQSxnRkF5SEM7QUFwSUQsbUNBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixxQ0FBd0c7QUFDeEcscUNBQXFDO0FBRXJDLDBGQUE2RztBQUU3Ryx5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUU5QixLQUFLLFVBQVUsa0NBQWtDLENBQ3RELFNBQWlCLEVBQUUsTUFBbUMsRUFBRSxtQkFBbUQ7SUFFM0cseUNBQXlDO0lBQ3pDLHNEQUFzRDtJQUN0RCw2R0FBNkc7SUFDN0csMEVBQTBFO0lBQzFFLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssc0JBQXNCLEVBQUUsQ0FBQztRQUNwRCxPQUFPLENBQUM7Z0JBQ04sWUFBWSxFQUFFLElBQUk7Z0JBQ2xCLFlBQVksRUFBRSxzQkFBc0I7Z0JBQ3BDLGFBQWEsRUFBRSxFQUFFO2dCQUNqQixZQUFZLEVBQUUsRUFBRTtnQkFDaEIsT0FBTyxFQUFFLFFBQVE7Z0JBQ2pCLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBVSxFQUFFLEVBQUUsR0FBRSxDQUFDO2FBQ2hDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxrQ0FBa0M7SUFDbEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRSxDQUFDO1FBQ2xELE9BQU8sb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssdUJBQXVCLEVBQUUsQ0FBQztRQUNyRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxNQUFNLEdBQUcsR0FBd0IsRUFBRSxDQUFDO0lBQ3BDLE1BQU0saUJBQWlCLEdBQUcs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QUFTLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztJQUU3RixzQ0FBc0M7SUFDdEMsd0VBQXdFO0lBQ3hFLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDbkQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsS0FBSyxVQUFVLGNBQWMsQ0FBQyxTQUFpQixFQUFFLG1CQUFtRCxFQUFFLGFBQXVCO0lBQzNILE1BQU0sUUFBUSxHQUFHLENBQUMsTUFBTSxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLDJCQUEyQixDQUFDO0lBRXhHLE9BQU8sUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBjbGFzc2lmeUNoYW5nZXMsIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgUHJvcERpZmZzIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgZmxhdE1hcCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IENmbkV2YWx1YXRpb25FeGNlcHRpb24sIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcblxuLy8gbmFtZXNwYWNlIG9iamVjdCBpbXBvcnRzIHdvbid0IHdvcmsgaW4gdGhlIGJ1bmRsZSBmb3IgZnVuY3Rpb24gZXhwb3J0c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbmNvbnN0IGFyY2hpdmVyID0gcmVxdWlyZSgnYXJjaGl2ZXInKTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlTGFtYmRhRnVuY3Rpb25DaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIC8vIGlmIHRoZSBjaGFuZ2UgaXMgZm9yIGEgTGFtYmRhIFZlcnNpb24sXG4gIC8vIGlnbm9yZSBpdCBieSByZXR1cm5pbmcgYW4gZW1wdHkgaG90c3dhcCBvcGVyYXRpb24gLVxuICAvLyB3ZSB3aWxsIHB1Ymxpc2ggYSBuZXcgdmVyc2lvbiB3aGVuIHdlIGdldCB0byBob3Rzd2FwcGluZyB0aGUgYWN0dWFsIEZ1bmN0aW9uIHRoaXMgVmVyc2lvbiBwb2ludHMgdG8sIGJlbG93XG4gIC8vIChWZXJzaW9ucyBjYW4ndCBiZSBjaGFuZ2VkIGluIENsb3VkRm9ybWF0aW9uIGFueXdheSwgdGhleSdyZSBpbW11dGFibGUpXG4gIGlmIChjaGFuZ2UubmV3VmFsdWUuVHlwZSA9PT0gJ0FXUzo6TGFtYmRhOjpWZXJzaW9uJykge1xuICAgIHJldHVybiBbe1xuICAgICAgaG90c3dhcHBhYmxlOiB0cnVlLFxuICAgICAgcmVzb3VyY2VUeXBlOiAnQVdTOjpMYW1iZGE6OlZlcnNpb24nLFxuICAgICAgcmVzb3VyY2VOYW1lczogW10sXG4gICAgICBwcm9wc0NoYW5nZWQ6IFtdLFxuICAgICAgc2VydmljZTogJ2xhbWJkYScsXG4gICAgICBhcHBseTogYXN5bmMgKF9zZGs6IElTREspID0+IHt9LFxuICAgIH1dO1xuICB9XG5cbiAgLy8gd2UgaGFuZGxlIEFsaWFzZXMgc3BlY2lhbGx5IHRvb1xuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6QWxpYXMnKSB7XG4gICAgcmV0dXJuIGNsYXNzaWZ5QWxpYXNDaGFuZ2VzKGNoYW5nZSk7XG4gIH1cblxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgIT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmV0OiBDaGFuZ2VIb3Rzd2FwUmVzdWx0ID0gW107XG4gIGNvbnN0IGNsYXNzaWZpZWRDaGFuZ2VzID0gY2xhc3NpZnlDaGFuZ2VzKGNoYW5nZSwgWydDb2RlJywgJ0Vudmlyb25tZW50JywgJ0Rlc2NyaXB0aW9uJ10pO1xuICBjbGFzc2lmaWVkQ2hhbmdlcy5yZXBvcnROb25Ib3Rzd2FwcGFibGVQcm9wZXJ0eUNoYW5nZXMocmV0KTtcblxuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZCwgY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LkZ1bmN0aW9uTmFtZSk7XG4gIGNvbnN0IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzID0gT2JqZWN0LmtleXMoY2xhc3NpZmllZENoYW5nZXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICBpZiAobmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIHJldC5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgICBwcm9wc0NoYW5nZWQ6IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgc2VydmljZTogJ2xhbWJkYScsXG4gICAgICByZXNvdXJjZU5hbWVzOiBbXG4gICAgICAgIGBMYW1iZGEgRnVuY3Rpb24gJyR7ZnVuY3Rpb25OYW1lfSdgLFxuICAgICAgICAvLyBhZGQgVmVyc2lvbiBoZXJlIGlmIHdlJ3JlIHB1Ymxpc2hpbmcgYSBuZXcgb25lXG4gICAgICAgIC4uLmF3YWl0IHJlbmRlclZlcnNpb25zKGxvZ2ljYWxJZCwgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgW2BMYW1iZGEgVmVyc2lvbiBmb3IgRnVuY3Rpb24gJyR7ZnVuY3Rpb25OYW1lfSdgXSksXG4gICAgICAgIC8vIGFkZCBhbnkgQWxpYXNlcyB0aGF0IHdlIGFyZSBob3Rzd2FwcGluZyBoZXJlXG4gICAgICAgIC4uLmF3YWl0IHJlbmRlckFsaWFzZXMobG9naWNhbElkLCBldmFsdWF0ZUNmblRlbXBsYXRlLCBhc3luYyAoYWxpYXMpID0+IGBMYW1iZGEgQWxpYXMgJyR7YWxpYXN9JyBmb3IgRnVuY3Rpb24gJyR7ZnVuY3Rpb25OYW1lfSdgKSxcbiAgICAgIF0sXG4gICAgICBhcHBseTogYXN5bmMgKHNkazogSVNESykgPT4ge1xuICAgICAgICBjb25zdCBsYW1iZGFDb2RlQ2hhbmdlID0gYXdhaXQgZXZhbHVhdGVMYW1iZGFGdW5jdGlvblByb3BzKFxuICAgICAgICAgIGNsYXNzaWZpZWRDaGFuZ2VzLmhvdHN3YXBwYWJsZVByb3BzLCBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uUnVudGltZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGxhbWJkYUNvZGVDaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24sIGFsaWFzZXNOYW1lcyB9ID0gYXdhaXQgdmVyc2lvbnNBbmRBbGlhc2VzKGxvZ2ljYWxJZCwgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gICAgICAgIGNvbnN0IGxhbWJkYSA9IHNkay5sYW1iZGEoKTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uczogUHJvbWlzZTxhbnk+W10gPSBbXTtcblxuICAgICAgICBpZiAobGFtYmRhQ29kZUNoYW5nZS5jb2RlICE9PSB1bmRlZmluZWQgfHwgbGFtYmRhQ29kZUNoYW5nZS5jb25maWd1cmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGxhbWJkYUNvZGVDaGFuZ2UuY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IGxhbWJkYS51cGRhdGVGdW5jdGlvbkNvZGUoe1xuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgUzNCdWNrZXQ6IGxhbWJkYUNvZGVDaGFuZ2UuY29kZS5zM0J1Y2tldCxcbiAgICAgICAgICAgICAgUzNLZXk6IGxhbWJkYUNvZGVDaGFuZ2UuY29kZS5zM0tleSxcbiAgICAgICAgICAgICAgSW1hZ2VVcmk6IGxhbWJkYUNvZGVDaGFuZ2UuY29kZS5pbWFnZVVyaSxcbiAgICAgICAgICAgICAgWmlwRmlsZTogbGFtYmRhQ29kZUNoYW5nZS5jb2RlLmZ1bmN0aW9uQ29kZVppcCxcbiAgICAgICAgICAgICAgUzNPYmplY3RWZXJzaW9uOiBsYW1iZGFDb2RlQ2hhbmdlLmNvZGUuczNPYmplY3RWZXJzaW9uLFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICAgICAgICBhd2FpdCB3YWl0Rm9yTGFtYmRhc1Byb3BlcnRpZXNVcGRhdGVUb0ZpbmlzaCh1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSwgbGFtYmRhLCBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlLmNvbmZpZ3VyYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVJlcXVlc3Q6IEFXUy5MYW1iZGEuVXBkYXRlRnVuY3Rpb25Db25maWd1cmF0aW9uUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhbWJkYUNvZGVDaGFuZ2UuY29uZmlndXJhdGlvbnMuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB1cGRhdGVSZXF1ZXN0LkRlc2NyaXB0aW9uID0gbGFtYmRhQ29kZUNoYW5nZS5jb25maWd1cmF0aW9ucy5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYW1iZGFDb2RlQ2hhbmdlLmNvbmZpZ3VyYXRpb25zLmVudmlyb25tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdXBkYXRlUmVxdWVzdC5FbnZpcm9ubWVudCA9IGxhbWJkYUNvZGVDaGFuZ2UuY29uZmlndXJhdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IGxhbWJkYS51cGRhdGVGdW5jdGlvbkNvbmZpZ3VyYXRpb24odXBkYXRlUmVxdWVzdCkucHJvbWlzZSgpO1xuICAgICAgICAgICAgYXdhaXQgd2FpdEZvckxhbWJkYXNQcm9wZXJ0aWVzVXBkYXRlVG9GaW5pc2godXBkYXRlRnVuY3Rpb25Db2RlUmVzcG9uc2UsIGxhbWJkYSwgZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBvbmx5IGlmIHRoZSBjb2RlIGNoYW5nZWQgaXMgdGhlcmUgYW55IHBvaW50IGluIHB1Ymxpc2hpbmcgYSBuZXcgVmVyc2lvblxuICAgICAgICAgIGlmICh2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcHVibGlzaFZlcnNpb25Qcm9taXNlID0gbGFtYmRhLnB1Ymxpc2hWZXJzaW9uKHtcbiAgICAgICAgICAgICAgRnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICB9KS5wcm9taXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChhbGlhc2VzTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBWZXJzaW9uIHRvIGZpbmlzaCBwdWJsaXNoaW5nXG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25VcGRhdGUgPSBhd2FpdCBwdWJsaXNoVmVyc2lvblByb21pc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlc05hbWVzKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS51cGRhdGVBbGlhcyh7XG4gICAgICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgIE5hbWU6IGFsaWFzLFxuICAgICAgICAgICAgICAgICAgRnVuY3Rpb25WZXJzaW9uOiB2ZXJzaW9uVXBkYXRlLlZlcnNpb24sXG4gICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHB1Ymxpc2hWZXJzaW9uUHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIGFsbCBvZiBvdXIgdXBkYXRlcyBpbiBwYXJhbGxlbFxuICAgICAgICAvLyBMaW1pdGVkIHNldCBvZiB1cGRhdGVzIHBlciBmdW5jdGlvblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwob3BlcmF0aW9ucyk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIGNoYW5nZXMgdG8gdGhpcyBBbGlhcyBhcmUgaG90c3dhcHBhYmxlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBjbGFzc2lmeUFsaWFzQ2hhbmdlcyhjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk6IENoYW5nZUhvdHN3YXBSZXN1bHQge1xuICBjb25zdCByZXQ6IENoYW5nZUhvdHN3YXBSZXN1bHQgPSBbXTtcbiAgY29uc3QgY2xhc3NpZmllZENoYW5nZXMgPSBjbGFzc2lmeUNoYW5nZXMoY2hhbmdlLCBbJ0Z1bmN0aW9uVmVyc2lvbiddKTtcbiAgY2xhc3NpZmllZENoYW5nZXMucmVwb3J0Tm9uSG90c3dhcHBhYmxlUHJvcGVydHlDaGFuZ2VzKHJldCk7XG5cbiAgY29uc3QgbmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMgPSBPYmplY3Qua2V5cyhjbGFzc2lmaWVkQ2hhbmdlcy5ob3Rzd2FwcGFibGVQcm9wcyk7XG4gIGlmIChuYW1lc09mSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0LnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiB0cnVlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWUuVHlwZSxcbiAgICAgIHByb3BzQ2hhbmdlZDogW10sXG4gICAgICBzZXJ2aWNlOiAnbGFtYmRhJyxcbiAgICAgIHJlc291cmNlTmFtZXM6IFtdLFxuICAgICAgYXBwbHk6IGFzeW5jIChfc2RrOiBJU0RLKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBob3Rzd2FwcGFibGUgcHJvcGVydGllcyBvZiBhbiBBV1M6OkxhbWJkYTo6RnVuY3Rpb24gYW5kXG4gKiBSZXR1cm5zIGEgYExhbWJkYUZ1bmN0aW9uQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIGhvdHN3YXBwYWJsZS5cbiAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGNoYW5nZSBpcyBub3QgaG90c3dhcHBhYmxlLlxuICovXG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZUxhbWJkYUZ1bmN0aW9uUHJvcHMoXG4gIGhvdHN3YXBwYWJsZVByb3BDaGFuZ2VzOiBQcm9wRGlmZnMsIHJ1bnRpbWU6IHN0cmluZywgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxMYW1iZGFGdW5jdGlvbkNoYW5nZSB8IHVuZGVmaW5lZD4ge1xuICAvKlxuICAgKiBBdCBmaXJzdCBnbGFuY2UsIHdlIHdvdWxkIHdhbnQgdG8gaW5pdGlhbGl6ZSB0aGVzZSB1c2luZyB0aGUgXCJwcmV2aW91c1wiIHZhbHVlcyAoY2hhbmdlLm9sZFZhbHVlKSxcbiAgICogaW4gY2FzZSBvbmx5IG9uZSBvZiB0aGVtIGNoYW5nZWQsIGxpa2UgdGhlIGtleSwgYW5kIHRoZSBCdWNrZXQgc3RheWVkIHRoZSBzYW1lLlxuICAgKiBIb3dldmVyLCB0aGF0IGFjdHVhbGx5IGZhaWxzIGZvciBvbGQtc3R5bGUgc3ludGhlc2lzLCB3aGljaCB1c2VzIENGTiBQYXJhbWV0ZXJzIVxuICAgKiBCZWNhdXNlIHRoZSBuYW1lcyBvZiB0aGUgUGFyYW1ldGVycyBkZXBlbmQgb24gdGhlIGhhc2ggb2YgdGhlIEFzc2V0LFxuICAgKiB0aGUgUGFyYW1ldGVycyB1c2VkIGZvciB0aGUgXCJvbGRcIiB2YWx1ZXMgbm8gbG9uZ2VyIGV4aXN0IGluIGBhc3NldFBhcmFtc2AgYXQgdGhpcyBwb2ludCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZXMgYXZhaWxhYmxlIHRvIGV2YWx1YXRlIHRoZSBDRk4gZXhwcmVzc2lvbiB3aXRoLlxuICAgKiBGb3J0dW5hdGVseSwgdGhlIGRpZmYgd2lsbCBhbHdheXMgaW5jbHVkZSBib3RoIHRoZSBzM0J1Y2tldCBhbmQgczNLZXkgcGFydHMgb2YgdGhlIExhbWJkYSdzIENvZGUgcHJvcGVydHksXG4gICAqIGV2ZW4gaWYgb25seSBvbmUgb2YgdGhlbSB3YXMgYWN0dWFsbHkgY2hhbmdlZCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgbmVlZCB0aGUgXCJvbGRcIiB2YWx1ZXMgYXQgYWxsLCBhbmQgd2UgY2FuIHNhZmVseSBpbml0aWFsaXplIHRoZXNlIHdpdGgganVzdCBgJydgLlxuICAgKi9cbiAgbGV0IGNvZGU6IExhbWJkYUZ1bmN0aW9uQ29kZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgbGV0IGRlc2NyaXB0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCBlbnZpcm9ubWVudDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGNvbnN0IHVwZGF0ZWRQcm9wTmFtZSBpbiBob3Rzd2FwcGFibGVQcm9wQ2hhbmdlcykge1xuICAgIGNvbnN0IHVwZGF0ZWRQcm9wID0gaG90c3dhcHBhYmxlUHJvcENoYW5nZXNbdXBkYXRlZFByb3BOYW1lXTtcblxuICAgIHN3aXRjaCAodXBkYXRlZFByb3BOYW1lKSB7XG4gICAgICBjYXNlICdDb2RlJzpcbiAgICAgICAgbGV0IHMzQnVja2V0LCBzM0tleSwgczNPYmplY3RWZXJzaW9uLCBpbWFnZVVyaSwgZnVuY3Rpb25Db2RlWmlwO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmV3UHJvcE5hbWUgaW4gdXBkYXRlZFByb3AubmV3VmFsdWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld1Byb3BOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdTM0J1Y2tldCc6XG4gICAgICAgICAgICAgIHMzQnVja2V0ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTM0tleSc6XG4gICAgICAgICAgICAgIHMzS2V5ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTM09iamVjdFZlcnNpb24nOlxuICAgICAgICAgICAgICBzM09iamVjdFZlcnNpb24gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ltYWdlVXJpJzpcbiAgICAgICAgICAgICAgaW1hZ2VVcmkgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1ppcEZpbGUnOlxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGNyZWF0ZSBhIHppcCBwYWNrYWdlIGNvbnRhaW5pbmcgYSBmaWxlIHdpdGggdGhlIGlubGluZSBjb2RlXG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ29kZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUnVudGltZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHJ1bnRpbWUpO1xuICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uUnVudGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZmlsZSBleHRlbnNpb24gbXVzdCBiZSBjaG9zZW4gZGVwZW5kaW5nIG9uIHRoZSBydW50aW1lXG4gICAgICAgICAgICAgIGNvbnN0IGNvZGVGaWxlRXh0ID0gZGV0ZXJtaW5lQ29kZUZpbGVFeHRGcm9tUnVudGltZShmdW5jdGlvblJ1bnRpbWUpO1xuICAgICAgICAgICAgICBmdW5jdGlvbkNvZGVaaXAgPSBhd2FpdCB6aXBTdHJpbmcoYGluZGV4LiR7Y29kZUZpbGVFeHR9YCwgZnVuY3Rpb25Db2RlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGUgPSB7XG4gICAgICAgICAgczNCdWNrZXQsXG4gICAgICAgICAgczNLZXksXG4gICAgICAgICAgczNPYmplY3RWZXJzaW9uLFxuICAgICAgICAgIGltYWdlVXJpLFxuICAgICAgICAgIGZ1bmN0aW9uQ29kZVppcCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEZXNjcmlwdGlvbic6XG4gICAgICAgIGRlc2NyaXB0aW9uID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0Vudmlyb25tZW50JzpcbiAgICAgICAgZW52aXJvbm1lbnQgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gd2Ugd2lsbCBuZXZlciBnZXQgaGVyZSwgYnV0IGp1c3QgaW4gY2FzZSB3ZSBkbyB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IgKCd3aGlsZSBhcHBseSgpaW5nLCBmb3VuZCBhIHByb3BlcnR5IHRoYXQgY2Fubm90IGJlIGhvdHN3YXBwZWQuIFBsZWFzZSByZXBvcnQgdGhpcyBhdCBnaXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy9uZXcvY2hvb3NlJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29uZmlndXJhdGlvbnMgPSBkZXNjcmlwdGlvbiB8fCBlbnZpcm9ubWVudCA/IHsgZGVzY3JpcHRpb24sIGVudmlyb25tZW50IH0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb2RlIHx8IGNvbmZpZ3VyYXRpb25zID8geyBjb2RlLCBjb25maWd1cmF0aW9ucyB9IDogdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25Db2RlIHtcbiAgcmVhZG9ubHkgczNCdWNrZXQ/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHMzS2V5Pzogc3RyaW5nO1xuICByZWFkb25seSBzM09iamVjdFZlcnNpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGltYWdlVXJpPzogc3RyaW5nO1xuICByZWFkb25seSBmdW5jdGlvbkNvZGVaaXA/OiBCdWZmZXI7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNvbmZpZ3VyYXRpb25zIHtcbiAgcmVhZG9ubHkgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGVudmlyb25tZW50PzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ2hhbmdlIHtcbiAgcmVhZG9ubHkgY29kZT86IExhbWJkYUZ1bmN0aW9uQ29kZTtcbiAgcmVhZG9ubHkgY29uZmlndXJhdGlvbnM/OiBMYW1iZGFGdW5jdGlvbkNvbmZpZ3VyYXRpb25zO1xufVxuXG4vKipcbiAqIENvbXByZXNzIGEgc3RyaW5nIGFzIGEgZmlsZSwgcmV0dXJuaW5nIGEgcHJvbWlzZSBmb3IgdGhlIHppcCBidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtYXJjaGl2ZXIvaXNzdWVzLzM0MlxuICovXG5mdW5jdGlvbiB6aXBTdHJpbmcoZmlsZU5hbWU6IHN0cmluZywgcmF3U3RyaW5nOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlcnM6IEJ1ZmZlcltdID0gW107XG5cbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgV3JpdGFibGUoKTtcblxuICAgIGNvbnZlcnRlci5fd3JpdGUgPSAoY2h1bms6IEJ1ZmZlciwgXzogc3RyaW5nLCBjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4ge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBjb252ZXJ0ZXIub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuXG4gICAgYXJjaGl2ZS5vbignZXJyb3InLCAoZXJyOiBhbnkpID0+IHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH0pO1xuXG4gICAgYXJjaGl2ZS5waXBlKGNvbnZlcnRlcik7XG5cbiAgICBhcmNoaXZlLmFwcGVuZChyYXdTdHJpbmcsIHtcbiAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgZGF0ZTogbmV3IERhdGUoJzE5ODAtMDEtMDFUMDA6MDA6MDAuMDAwWicpLCAvLyBBZGQgZGF0ZSB0byBtYWtlIHJlc3VsdGluZyB6aXAgZmlsZSBkZXRlcm1pbmlzdGljXG4gICAgfSk7XG5cbiAgICB2b2lkIGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICAqIEFmdGVyIGEgTGFtYmRhIEZ1bmN0aW9uIGlzIHVwZGF0ZWQsIGl0IGNhbm5vdCBiZSB1cGRhdGVkIGFnYWluIHVudGlsIHRoZVxuICAqIGBTdGF0ZT1BY3RpdmVgIGFuZCB0aGUgYExhc3RVcGRhdGVTdGF0dXM9U3VjY2Vzc2Z1bGAuXG4gICpcbiAgKiBEZXBlbmRpbmcgb24gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIExhbWJkYSBGdW5jdGlvbiB0aGlzIGNvdWxkIGhhcHBlbiByZWxhdGl2ZWx5IHF1aWNrbHlcbiAgKiBvciB2ZXJ5IHNsb3dseS4gRm9yIGV4YW1wbGUsIFppcCBiYXNlZCBmdW5jdGlvbnMgX25vdF8gaW4gYSBWUEMgY2FuIHRha2UgfjEgc2Vjb25kIHdoZXJlYXMgVlBDXG4gICogb3IgQ29udGFpbmVyIGZ1bmN0aW9ucyBjYW4gdGFrZSB+MjUgc2Vjb25kcyAoYW5kICdpZGxlJyBWUEMgZnVuY3Rpb25zIGNhbiB0YWtlIG1pbnV0ZXMpLlxuICAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvckxhbWJkYXNQcm9wZXJ0aWVzVXBkYXRlVG9GaW5pc2goXG4gIGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb246IEFXUy5MYW1iZGEuRnVuY3Rpb25Db25maWd1cmF0aW9uLCBsYW1iZGE6IEFXUy5MYW1iZGEsIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGZ1bmN0aW9uSXNJblZwY09yVXNlc0RvY2tlckZvckNvZGUgPSBjdXJyZW50RnVuY3Rpb25Db25maWd1cmF0aW9uLlZwY0NvbmZpZz8uVnBjSWQgfHxcbiAgICAgIGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb24uUGFja2FnZVR5cGUgPT09ICdJbWFnZSc7XG5cbiAgLy8gaWYgdGhlIGZ1bmN0aW9uIGlzIGRlcGxveWVkIGluIGEgVlBDIG9yIGlmIGl0IGlzIGEgY29udGFpbmVyIGltYWdlIGZ1bmN0aW9uXG4gIC8vIHRoZW4gdGhlIHVwZGF0ZSB3aWxsIHRha2UgbXVjaCBsb25nZXIgYW5kIHdlIGNhbiB3YWl0IGxvbmdlciBiZXR3ZWVuIGNoZWNrc1xuICAvLyBvdGhlcndpc2UsIHRoZSB1cGRhdGUgd2lsbCBiZSBxdWljaywgc28gYSAxLXNlY29uZCBkZWxheSBpcyBmaW5lXG4gIGNvbnN0IGRlbGF5U2Vjb25kcyA9IGZ1bmN0aW9uSXNJblZwY09yVXNlc0RvY2tlckZvckNvZGUgPyA1IDogMTtcblxuICAvLyBjb25maWd1cmUgYSBjdXN0b20gd2FpdGVyIHRvIHdhaXQgZm9yIHRoZSBmdW5jdGlvbiB1cGRhdGUgdG8gY29tcGxldGVcbiAgKGxhbWJkYSBhcyBhbnkpLmFwaS53YWl0ZXJzLnVwZGF0ZUZ1bmN0aW9uUHJvcGVydGllc1RvRmluaXNoID0ge1xuICAgIG5hbWU6ICdVcGRhdGVGdW5jdGlvblByb3BlcnRpZXNUb0ZpbmlzaCcsXG4gICAgb3BlcmF0aW9uOiAnZ2V0RnVuY3Rpb24nLFxuICAgIC8vIGVxdWF0ZXMgdG8gMSBtaW51dGUgZm9yIHppcCBmdW5jdGlvbiBub3QgaW4gYSBWUEMgYW5kXG4gICAgLy8gNSBtaW51dGVzIGZvciBjb250YWluZXIgZnVuY3Rpb25zIG9yIGZ1bmN0aW9uIGluIGEgVlBDXG4gICAgbWF4QXR0ZW1wdHM6IDYwLFxuICAgIGRlbGF5OiBkZWxheVNlY29uZHMsXG4gICAgYWNjZXB0b3JzOiBbXG4gICAgICB7XG4gICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgYXJndW1lbnQ6IFwiQ29uZmlndXJhdGlvbi5MYXN0VXBkYXRlU3RhdHVzID09ICdTdWNjZXNzZnVsJyAmJiBDb25maWd1cmF0aW9uLlN0YXRlID09ICdBY3RpdmUnXCIsXG4gICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICBzdGF0ZTogJ3N1Y2Nlc3MnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICBhcmd1bWVudDogJ0NvbmZpZ3VyYXRpb24uTGFzdFVwZGF0ZVN0YXR1cycsXG4gICAgICAgIGV4cGVjdGVkOiAnRmFpbGVkJyxcbiAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcblxuICBjb25zdCB1cGRhdGVGdW5jdGlvblByb3BlcnRpZXNXYWl0ZXIgPSBuZXcgKEFXUyBhcyBhbnkpLlJlc291cmNlV2FpdGVyKGxhbWJkYSwgJ3VwZGF0ZUZ1bmN0aW9uUHJvcGVydGllc1RvRmluaXNoJyk7XG4gIGF3YWl0IHVwZGF0ZUZ1bmN0aW9uUHJvcGVydGllc1dhaXRlci53YWl0KHtcbiAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgfSkucHJvbWlzZSgpO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIExhbWJkYSBydW50aW1lIHN0cmluZy5cbiAqIFdlIHVzZSB0aGlzIGV4dGVuc2lvbiB0byBjcmVhdGUgYSBkZXBsb3ltZW50IHBhY2thZ2UgZnJvbSBMYW1iZGEgaW5saW5lIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUNvZGVGaWxlRXh0RnJvbVJ1bnRpbWUocnVudGltZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgnbm9kZScpKSB7XG4gICAgcmV0dXJuICdqcyc7XG4gIH1cbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgncHl0aG9uJykpIHtcbiAgICByZXR1cm4gJ3B5JztcbiAgfVxuICAvLyBDdXJyZW50bHkgaW5saW5lIGNvZGUgb25seSBzdXBwb3J0cyBOb2RlLmpzIGFuZCBQeXRob24sIGlnbm9yaW5nIG90aGVyIHJ1bnRpbWVzLlxuICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9hd3MtcHJvcGVydGllcy1sYW1iZGEtZnVuY3Rpb24tY29kZS5odG1sI2F3cy1wcm9wZXJ0aWVzLWxhbWJkYS1mdW5jdGlvbi1jb2RlLXByb3BlcnRpZXNcbiAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYHJ1bnRpbWUgJHtydW50aW1lfSBpcyB1bnN1cHBvcnRlZCwgb25seSBub2RlLmpzIGFuZCBweXRob24gcnVudGltZXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG59XG5cbi8qKlxuICogRmluZHMgYWxsIFZlcnNpb25zIHRoYXQgcmVmZXJlbmNlIGFuIEFXUzo6TGFtYmRhOjpGdW5jdGlvbiB3aXRoIGxvZ2ljYWwgSUQgYGxvZ2ljYWxJZGBcbiAqIGFuZCBBbGlhc2VzIHRoYXQgcmVmZXJlbmNlIHRob3NlIFZlcnNpb25zLlxuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJzaW9uc0FuZEFsaWFzZXMobG9naWNhbElkOiBzdHJpbmcsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSkge1xuICAvLyBmaW5kIGFsbCBMYW1iZGEgVmVyc2lvbnMgdGhhdCByZWZlcmVuY2UgdGhpcyBGdW5jdGlvblxuICBjb25zdCB2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24gPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKVxuICAgIC5maWx0ZXIociA9PiByLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6VmVyc2lvbicpO1xuICAvLyBmaW5kIGFsbCBMYW1iZGEgQWxpYXNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgYWJvdmUgVmVyc2lvbnNcbiAgY29uc3QgYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMgPSBmbGF0TWFwKHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbiwgdiA9PlxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyh2LkxvZ2ljYWxJZCkpO1xuICAvLyBMaW1pdGVkIHNldCBvZiB1cGRhdGVzIHBlciBmdW5jdGlvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgY29uc3QgYWxpYXNlc05hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMubWFwKGEgPT5cbiAgICBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhLlByb3BlcnRpZXM/Lk5hbWUpKSk7XG5cbiAgcmV0dXJuIHsgdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLCBhbGlhc2VzTmFtZXMgfTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdHJpbmcgdXNlZCBpbiBkaXNwbGF5aW5nIEFsaWFzIHJlc291cmNlIG5hbWVzIHRoYXQgcmVmZXJlbmNlIHRoZSBzcGVjaWZpZWQgTGFtYmRhIEZ1bmN0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckFsaWFzZXMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIGNhbGxiYWNrZm46ICh2YWx1ZTogYW55LCBpbmRleDogbnVtYmVyLCBhcnJheTogYW55W10pID0+IFByb21pc2U8c3RyaW5nPixcbik6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgYWxpYXNlc05hbWVzID0gKGF3YWl0IHZlcnNpb25zQW5kQWxpYXNlcyhsb2dpY2FsSWQsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpKS5hbGlhc2VzTmFtZXM7XG5cbiAgLy8gTGltaXRlZCBzZXQgb2YgdXBkYXRlcyBwZXIgZnVuY3Rpb25cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gIHJldHVybiBQcm9taXNlLmFsbChhbGlhc2VzTmFtZXMubWFwKGNhbGxiYWNrZm4pKTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzdHJpbmcgdXNlZCBpbiBkaXNwbGF5aW5nIFZlcnNpb24gcmVzb3VyY2UgbmFtZXMgdGhhdCByZWZlcmVuY2UgdGhlIHNwZWNpZmllZCBMYW1iZGEgRnVuY3Rpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVmVyc2lvbnMobG9naWNhbElkOiBzdHJpbmcsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSwgdmVyc2lvblN0cmluZzogc3RyaW5nW10pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IHZlcnNpb25zID0gKGF3YWl0IHZlcnNpb25zQW5kQWxpYXNlcyhsb2dpY2FsSWQsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpKS52ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb247XG5cbiAgcmV0dXJuIHZlcnNpb25zLmxlbmd0aCA+IDAgPyB2ZXJzaW9uU3RyaW5nIDogW107XG59XG4iXX0=