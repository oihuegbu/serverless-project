"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var SDK_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK = void 0;
exports.isUnrecoverableAwsError = isUnrecoverableAwsError;
const crypto = require("crypto");
const AWS = require("aws-sdk");
const _env_1 = require("./_env");
const account_cache_1 = require("./account-cache");
const cached_1 = require("./cached");
const tracing_1 = require("../../util/tracing");
// We need to map regions to domain suffixes, and the SDK already has a function to do this.
// It's not part of the public API, but it's also unlikely to go away.
//
// Reuse that function, and add a safety check, so we don't accidentally break if they ever
// refactor that away.
/* eslint-disable @typescript-eslint/no-require-imports */
const regionUtil = require('aws-sdk/lib/region_config');
require('aws-sdk/lib/maintenance_mode_message').suppress = true;
/* eslint-enable @typescript-eslint/no-require-imports */
if (!regionUtil.getEndpointSuffix) {
    throw new Error('This version of AWS SDK for JS does not have the \'getEndpointSuffix\' function!');
}
/**
 * Base functionality of SDK without credential fetching
 */
let SDK = SDK_1 = class SDK {
    constructor(_credentials, region, httpOptions = {}, sdkOptions = {}) {
        this._credentials = _credentials;
        this.sdkOptions = sdkOptions;
        /**
         * Default retry options for SDK clients.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        /**
         * The more generous retry policy for CloudFormation, which has a 1 TPM limit on certain APIs,
         * which are abundantly used for deployment tracking, ...
         *
         * So we're allowing way more retries, but waiting a bit more.
         */
        this.cloudFormationRetryOptions = { maxRetries: 10, retryDelayOptions: { base: 1000 } };
        /**
         * STS is used to check credential validity, don't do too many retries.
         */
        this.stsRetryOptions = { maxRetries: 3, retryDelayOptions: { base: 100 } };
        /**
         * Whether we have proof that the credentials have not expired
         *
         * We need to do some manual plumbing around this because the JS SDKv2 treats `ExpiredToken`
         * as retriable and we have hefty retries on CFN calls making the CLI hang for a good 15 minutes
         * if the credentials have expired.
         */
        this._credentialsValidated = false;
        this.config = {
            ...httpOptions,
            ...this.retryOptions,
            credentials: _credentials,
            region,
            logger: { log: (...messages) => messages.forEach(m => (0, _env_1.trace)('%s', m)) },
        };
        this.currentRegion = region;
    }
    appendCustomUserAgent(userAgentData) {
        if (!userAgentData) {
            return;
        }
        const currentCustomUserAgent = this.config.customUserAgent;
        this.config.customUserAgent = currentCustomUserAgent
            ? `${currentCustomUserAgent} ${userAgentData}`
            : userAgentData;
    }
    removeCustomUserAgent(userAgentData) {
        this.config.customUserAgent = this.config.customUserAgent?.replace(userAgentData, '');
    }
    lambda() {
        return this.wrapServiceErrorHandling(new AWS.Lambda(this.config));
    }
    cloudFormation() {
        return this.wrapServiceErrorHandling(new AWS.CloudFormation({
            ...this.config,
            ...this.cloudFormationRetryOptions,
        }));
    }
    ec2() {
        return this.wrapServiceErrorHandling(new AWS.EC2(this.config));
    }
    iam() {
        return this.wrapServiceErrorHandling(new AWS.IAM(this.config));
    }
    ssm() {
        return this.wrapServiceErrorHandling(new AWS.SSM(this.config));
    }
    s3({ needsMd5Checksums: apiRequiresMd5Checksum = false, } = {}) {
        const config = { ...this.config };
        if (crypto.getFips() && apiRequiresMd5Checksum) {
            // This should disappear for SDKv3; in SDKv3, we can always force the client to use SHA256 checksums
            throw new Error('This operation requires MD5 for integrity purposes; unfortunately, it therefore is not available in FIPS enabled environments.');
        }
        if (crypto.getFips()) {
            // In FIPS enabled environments, the MD5 algorithm is not available for use in crypto module.
            // However by default the S3 client is using an MD5 checksum for content integrity checking.
            // While this usage is technically allowed in FIPS (MD5 is only prohibited for cryptographic use),
            // in practice it is just easier to use an allowed checksum mechanism.
            // We are disabling the S3 content checksums, and are re-enabling the regular SigV4 body signing.
            // SigV4 uses SHA256 for their content checksum.
            //
            // As far as we know, this configuration will work for most APIs except:
            // - DeleteObjects (note the plural)
            // - PutObject to a bucket with Object Lock enabled.
            //
            // These APIs refuse to work without a content checksum at the S3 level (a SigV4 checksum is not
            // good enough). There is no way to get those to work with SHA256 in the SDKv2, but this limitation
            // will be alleviated once we migrate to SDKv3.
            config.s3DisableBodySigning = false;
            config.computeChecksums = false;
        }
        return this.wrapServiceErrorHandling(new AWS.S3(config));
    }
    route53() {
        return this.wrapServiceErrorHandling(new AWS.Route53(this.config));
    }
    ecr() {
        return this.wrapServiceErrorHandling(new AWS.ECR(this.config));
    }
    ecs() {
        return this.wrapServiceErrorHandling(new AWS.ECS(this.config));
    }
    elbv2() {
        return this.wrapServiceErrorHandling(new AWS.ELBv2(this.config));
    }
    secretsManager() {
        return this.wrapServiceErrorHandling(new AWS.SecretsManager(this.config));
    }
    kms() {
        return this.wrapServiceErrorHandling(new AWS.KMS(this.config));
    }
    stepFunctions() {
        return this.wrapServiceErrorHandling(new AWS.StepFunctions(this.config));
    }
    codeBuild() {
        return this.wrapServiceErrorHandling(new AWS.CodeBuild(this.config));
    }
    cloudWatchLogs() {
        return this.wrapServiceErrorHandling(new AWS.CloudWatchLogs(this.config));
    }
    appsync() {
        return this.wrapServiceErrorHandling(new AWS.AppSync(this.config));
    }
    async currentAccount() {
        // Get/refresh if necessary before we can access `accessKeyId`
        await this.forceCredentialRetrieval();
        return (0, cached_1.cached)(this, CURRENT_ACCOUNT_KEY, () => SDK_1.accountCache.fetch(this._credentials.accessKeyId, async () => {
            // if we don't have one, resolve from STS and store in cache.
            (0, _env_1.debug)('Looking up default account ID from STS');
            const result = await new AWS.STS({ ...this.config, ...this.stsRetryOptions }).getCallerIdentity().promise();
            const accountId = result.Account;
            const partition = result.Arn.split(':')[1];
            if (!accountId) {
                throw new Error('STS didn\'t return an account ID');
            }
            (0, _env_1.debug)('Default account ID:', accountId);
            // Save another STS call later if this one already succeeded
            this._credentialsValidated = true;
            return { accountId, partition };
        }));
    }
    /**
     * Return the current credentials
     *
     * Don't use -- only used to write tests around assuming roles.
     */
    async currentCredentials() {
        await this.forceCredentialRetrieval();
        return this._credentials;
    }
    /**
     * Force retrieval of the current credentials
     *
     * Relevant if the current credentials are AssumeRole credentials -- do the actual
     * lookup, and translate any error into a useful error message (taking into
     * account credential provenance).
     */
    async forceCredentialRetrieval() {
        try {
            await this._credentials.getPromise();
        }
        catch (e) {
            if (isUnrecoverableAwsError(e)) {
                throw e;
            }
            // Only reason this would fail is if it was an AssumRole. Otherwise,
            // reading from an INI file or reading env variables is unlikely to fail.
            (0, _env_1.debug)(`Assuming role failed: ${e.message}`);
            throw new Error([
                'Could not assume role in target account',
                ...this.sdkOptions.assumeRoleCredentialsSourceDescription
                    ? [`using ${this.sdkOptions.assumeRoleCredentialsSourceDescription}`]
                    : [],
                e.message,
                '. Please make sure that this role exists in the account. If it doesn\'t exist, (re)-bootstrap the environment ' +
                    'with the right \'--trust\', using the latest version of the CDK CLI.',
            ].join(' '));
        }
    }
    /**
     * Make sure the the current credentials are not expired
     */
    async validateCredentials() {
        if (this._credentialsValidated) {
            return;
        }
        await new AWS.STS({ ...this.config, ...this.stsRetryOptions }).getCallerIdentity().promise();
        this._credentialsValidated = true;
    }
    getEndpointSuffix(region) {
        return regionUtil.getEndpointSuffix(region);
    }
    /**
     * Return a wrapping object for the underlying service object
     *
     * Responds to failures in the underlying service calls, in two different
     * ways:
     *
     * - When errors are encountered, log the failing call and the error that
     *   it triggered (at debug level). This is necessary because the lack of
     *   stack traces in NodeJS otherwise makes it very hard to suss out where
     *   a certain AWS error occurred.
     * - The JS SDK has a funny business of wrapping any credential-based error
     *   in a super-generic (and in our case wrong) exception. If we then use a
     *   'ChainableTemporaryCredentials' and the target role doesn't exist,
     *   the error message that shows up by default is super misleading
     *   (https://github.com/aws/aws-sdk-js/issues/3272). We can fix this because
     *   the exception contains the "inner exception", so we unwrap and throw
     *   the correct error ("cannot assume role").
     *
     * The wrapping business below is slightly more complicated than you'd think
     * because we must hook into the `promise()` method of the object that's being
     * returned from the methods of the object that we wrap, so there's two
     * levels of wrapping going on, and also some exceptions to the wrapping magic.
     */
    wrapServiceErrorHandling(serviceObject) {
        const classObject = serviceObject.constructor.prototype;
        const self = this;
        return new Proxy(serviceObject, {
            get(obj, prop) {
                const real = obj[prop];
                // Things we don't want to intercept:
                // - Anything that's not a function.
                // - 'constructor', s3.upload() will use this to do some magic and we need the underlying constructor.
                // - Any method that's not on the service class (do not intercept 'makeRequest' and other helpers).
                if (prop === 'constructor' || !classObject.hasOwnProperty(prop) || !isFunction(real)) {
                    return real;
                }
                // NOTE: This must be a function() and not an () => {
                // because I need 'this' to be dynamically bound and not statically bound.
                // If your linter complains don't listen to it!
                return function () {
                    // Call the underlying function. If it returns an object with a promise()
                    // method on it, wrap that 'promise' method.
                    const args = [].slice.call(arguments, 0);
                    const response = real.apply(this, args);
                    // Don't intercept unless the return value is an object with a '.promise()' method.
                    if (typeof response !== 'object' || !response) {
                        return response;
                    }
                    if (!('promise' in response)) {
                        return response;
                    }
                    // Return an object with the promise method replaced with a wrapper which will
                    // do additional things to errors.
                    return Object.assign(Object.create(response), {
                        promise() {
                            return response.promise().catch((e) => {
                                e = self.makeDetailedException(e);
                                (0, _env_1.debug)(`Call failed: ${prop}(${JSON.stringify(args[0])}) => ${e.message} (code=${e.code})`);
                                return Promise.reject(e); // Re-'throw' the new error
                            });
                        },
                    });
                };
            },
        });
    }
    /**
     * Extract a more detailed error out of a generic error if we can
     *
     * If this is an error about Assuming Roles, add in the context showing the
     * chain of credentials we used to try to assume the role.
     */
    makeDetailedException(e) {
        // This is the super-generic "something's wrong" error that the JS SDK wraps other errors in.
        // https://github.com/aws/aws-sdk-js/blob/f0ac2e53457c7512883d0677013eacaad6cd8a19/lib/event_listeners.js#L84
        if (typeof e.message === 'string' && e.message.startsWith('Missing credentials in config')) {
            const original = e.originalError;
            if (original) {
                // When the SDK does a 'util.copy', they lose the Error-ness of the inner error
                // (they copy the Error's properties into a plain object) so make it an Error object again.
                e = Object.assign(new Error(), original);
            }
        }
        // At this point, the error might still be a generic "ChainableTemporaryCredentials failed"
        // error which wraps the REAL error (AssumeRole failed). We're going to replace the error
        // message with one that's more likely to help users, and tell them the most probable
        // fix (bootstrapping). The underlying service call failure will be appended below.
        if (e.message === 'Could not load credentials from ChainableTemporaryCredentials') {
            e.message = [
                'Could not assume role in target account',
                ...this.sdkOptions.assumeRoleCredentialsSourceDescription
                    ? [`using ${this.sdkOptions.assumeRoleCredentialsSourceDescription}`]
                    : [],
                '(did you bootstrap the environment with the right \'--trust\'s?)',
            ].join(' ');
        }
        // Replace the message on this error with a concatenation of all inner error messages.
        // Must more clear what's going on that way.
        e.message = allChainedExceptionMessages(e);
        return e;
    }
};
exports.SDK = SDK;
SDK.accountCache = new account_cache_1.AccountAccessKeyCache();
exports.SDK = SDK = SDK_1 = __decorate([
    tracing_1.traceMethods
], SDK);
const CURRENT_ACCOUNT_KEY = Symbol('current_account_key');
function isFunction(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Return the concatenated message of all exceptions in the AWS exception chain
 */
function allChainedExceptionMessages(e) {
    const ret = new Array();
    while (e) {
        ret.push(e.message);
        e = e.originalError;
    }
    return ret.join(': ');
}
/**
 * Return whether an error should not be recovered from
 */
function isUnrecoverableAwsError(e) {
    return e.code === 'ExpiredToken';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUE0Y0EsMERBRUM7QUE5Y0QsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUUvQixpQ0FBc0M7QUFDdEMsbURBQXdEO0FBQ3hELHFDQUFrQztBQUVsQyxnREFBa0Q7QUFFbEQsNEZBQTRGO0FBQzVGLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0YsMkZBQTJGO0FBQzNGLHNCQUFzQjtBQUV0QiwwREFBMEQ7QUFDMUQsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFDeEQsT0FBTyxDQUFDLHNDQUFzQyxDQUFDLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNoRSx5REFBeUQ7QUFFekQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0ZBQWtGLENBQUMsQ0FBQztBQUN0RyxDQUFDO0FBd0VEOztHQUVHO0FBRUksSUFBTSxHQUFHLFdBQVQsTUFBTSxHQUFHO0lBa0NkLFlBQ21CLFlBQTZCLEVBQzlDLE1BQWMsRUFDZCxjQUFvQyxFQUFFLEVBQ3JCLGFBQXlCLEVBQUU7UUFIM0IsaUJBQVksR0FBWixZQUFZLENBQWlCO1FBRzdCLGVBQVUsR0FBVixVQUFVLENBQWlCO1FBL0I5Qzs7V0FFRztRQUNjLGlCQUFZLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFFcEY7Ozs7O1dBS0c7UUFDYywrQkFBMEIsR0FBRyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsaUJBQWlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSyxFQUFFLEVBQUUsQ0FBQztRQUVyRzs7V0FFRztRQUNjLG9CQUFlLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLGlCQUFpQixF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QUFTLFVBQVUsQ0FBQyxDQUFNO0lBQ3hCLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLG1CQUFtQixDQUFDO0FBQzFELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsMkJBQTJCLENBQUMsQ0FBb0I7SUFDdkQsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUNoQyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBQ1QsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEIsQ0FBQyxHQUFJLENBQVMsQ0FBQyxhQUFhLENBQUM7SUFDL0IsQ0FBQztJQUNELE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQix1QkFBdUIsQ0FBQyxDQUFRO0lBQzlDLE9BQVEsQ0FBUyxDQUFDLElBQUksS0FBSyxjQUFjLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHR5cGUgeyBDb25maWd1cmF0aW9uT3B0aW9ucyB9IGZyb20gJ2F3cy1zZGsvbGliL2NvbmZpZy1iYXNlJztcbmltcG9ydCB7IGRlYnVnLCB0cmFjZSB9IGZyb20gJy4vX2Vudic7XG5pbXBvcnQgeyBBY2NvdW50QWNjZXNzS2V5Q2FjaGUgfSBmcm9tICcuL2FjY291bnQtY2FjaGUnO1xuaW1wb3J0IHsgY2FjaGVkIH0gZnJvbSAnLi9jYWNoZWQnO1xuaW1wb3J0IHsgQWNjb3VudCB9IGZyb20gJy4vc2RrLXByb3ZpZGVyJztcbmltcG9ydCB7IHRyYWNlTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWwvdHJhY2luZyc7XG5cbi8vIFdlIG5lZWQgdG8gbWFwIHJlZ2lvbnMgdG8gZG9tYWluIHN1ZmZpeGVzLCBhbmQgdGhlIFNESyBhbHJlYWR5IGhhcyBhIGZ1bmN0aW9uIHRvIGRvIHRoaXMuXG4vLyBJdCdzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLCBidXQgaXQncyBhbHNvIHVubGlrZWx5IHRvIGdvIGF3YXkuXG4vL1xuLy8gUmV1c2UgdGhhdCBmdW5jdGlvbiwgYW5kIGFkZCBhIHNhZmV0eSBjaGVjaywgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGJyZWFrIGlmIHRoZXkgZXZlclxuLy8gcmVmYWN0b3IgdGhhdCBhd2F5LlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5jb25zdCByZWdpb25VdGlsID0gcmVxdWlyZSgnYXdzLXNkay9saWIvcmVnaW9uX2NvbmZpZycpO1xucmVxdWlyZSgnYXdzLXNkay9saWIvbWFpbnRlbmFuY2VfbW9kZV9tZXNzYWdlJykuc3VwcHJlc3MgPSB0cnVlO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbmlmICghcmVnaW9uVXRpbC5nZXRFbmRwb2ludFN1ZmZpeCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdmVyc2lvbiBvZiBBV1MgU0RLIGZvciBKUyBkb2VzIG5vdCBoYXZlIHRoZSBcXCdnZXRFbmRwb2ludFN1ZmZpeFxcJyBmdW5jdGlvbiEnKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTM0NsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogSWYgQVBJcyBhcmUgdXNlZCB0aGF0IHJlcXVpcmUgTUQ1IGNoZWNrc3Vtcy5cbiAgICpcbiAgICogU29tZSBTMyBBUElzIGluIFNES3YyIGhhdmUgYSBidWcgdGhhdCBhbHdheXMgcmVxdWlyZXMgdGhlbSB0byB1c2UgYSBNRDUgY2hlY2tzdW0uXG4gICAqIFRoZXNlIEFQSXMgYXJlIG5vdCBnb2luZyB0byBiZSBzdXBwb3J0ZWQgaW4gYSBGSVBTIGVudmlyb25tZW50LlxuICAgKi9cbiAgbmVlZHNNZDVDaGVja3N1bXM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTREsge1xuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdFJlZ2lvbigpYCBvbiBTZGtQcm92aWRlciB3aGljaFxuICAgKiByZXByZXNlbnRzIHRoZSByZWdpb24gY29uZmlndXJlZCBpbiB0aGUgZGVmYXVsdCBjb25maWcpLlxuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudFJlZ2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQWNjb3VudCB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdEFjY291bnQoKWAgb24gU2RrUHJvdmlkZXIgd2hpY2hcbiAgICogcmVwcmVzZW50cyB0aGUgYWNjb3VudCBhdmFpbGFibGUgYnkgdXNpbmcgZGVmYXVsdCBjcmVkZW50aWFscykuXG4gICAqL1xuICBjdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQ+O1xuXG4gIGdldEVuZHBvaW50U3VmZml4KHJlZ2lvbjogc3RyaW5nKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBzdHJpbmcgYXMgdGhlIGV4dHJhIGluZm9ybWF0aW9uIHRvIHB1dCBpbnRvIHRoZSBVc2VyLUFnZW50IGhlYWRlciBmb3IgYW55IHJlcXVlc3RzIGludm9rZWQgYnkgdGhpcyBTREsuXG4gICAqIElmIHRoZSBzdHJpbmcgaXMgJ3VuZGVmaW5lZCcsIHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3QuXG4gICAqL1xuICBhcHBlbmRDdXN0b21Vc2VyQWdlbnQodXNlckFnZW50RGF0YT86IHN0cmluZyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIHN0cmluZyBmcm9tIHRoZSBleHRyYSBVc2VyLUFnZW50IGhlYWRlciBkYXRhIHVzZWQgZm9yIHJlcXVlc3RzIGludm9rZWQgYnkgdGhpcyBTREsuXG4gICAqL1xuICByZW1vdmVDdXN0b21Vc2VyQWdlbnQodXNlckFnZW50RGF0YTogc3RyaW5nKTogdm9pZDtcblxuICBsYW1iZGEoKTogQVdTLkxhbWJkYTtcbiAgY2xvdWRGb3JtYXRpb24oKTogQVdTLkNsb3VkRm9ybWF0aW9uO1xuICBlYzIoKTogQVdTLkVDMjtcbiAgaWFtKCk6IEFXUy5JQU07XG4gIHNzbSgpOiBBV1MuU1NNO1xuICBzMyhvcHRpb25zPzogUzNDbGllbnRPcHRpb25zKTogQVdTLlMzO1xuICByb3V0ZTUzKCk6IEFXUy5Sb3V0ZTUzO1xuICBlY3IoKTogQVdTLkVDUjtcbiAgZWNzKCk6IEFXUy5FQ1M7XG4gIGVsYnYyKCk6IEFXUy5FTEJ2MjtcbiAgc2VjcmV0c01hbmFnZXIoKTogQVdTLlNlY3JldHNNYW5hZ2VyO1xuICBrbXMoKTogQVdTLktNUztcbiAgc3RlcEZ1bmN0aW9ucygpOiBBV1MuU3RlcEZ1bmN0aW9ucztcbiAgY29kZUJ1aWxkKCk6IEFXUy5Db2RlQnVpbGQ7XG4gIGNsb3VkV2F0Y2hMb2dzKCk6IEFXUy5DbG91ZFdhdGNoTG9ncztcbiAgYXBwc3luYygpOiBBV1MuQXBwU3luYztcbn1cblxuLyoqXG4gKiBBZGRpdGlvbmFsIFNESyBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZGtPcHRpb25zIHtcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgZGVzY3JpcHRpdmUgc3RyaW5ncyB0aGF0IGluZGljYXRlIHdoZXJlIHRoZSBcIkFzc3VtZVJvbGVcIiBjcmVkZW50aWFscyBhcmUgY29taW5nIGZyb21cbiAgICpcbiAgICogV2lsbCBiZSBwcmludGVkIGluIGFuIGVycm9yIG1lc3NhZ2UgdG8gaGVscCB1c2VycyBkaWFnbm9zZSBhdXRoIHByb2JsZW1zLlxuICAgKi9cbiAgcmVhZG9ubHkgYXNzdW1lUm9sZUNyZWRlbnRpYWxzU291cmNlRGVzY3JpcHRpb24/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQmFzZSBmdW5jdGlvbmFsaXR5IG9mIFNESyB3aXRob3V0IGNyZWRlbnRpYWwgZmV0Y2hpbmdcbiAqL1xuQHRyYWNlTWV0aG9kc1xuZXhwb3J0IGNsYXNzIFNESyBpbXBsZW1lbnRzIElTREsge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBhY2NvdW50Q2FjaGUgPSBuZXcgQWNjb3VudEFjY2Vzc0tleUNhY2hlKCk7XG5cbiAgcHVibGljIHJlYWRvbmx5IGN1cnJlbnRSZWdpb246IHN0cmluZztcblxuICBwcml2YXRlIHJlYWRvbmx5IGNvbmZpZzogQ29uZmlndXJhdGlvbk9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcmV0cnkgb3B0aW9ucyBmb3IgU0RLIGNsaWVudHMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHJldHJ5T3B0aW9ucyA9IHsgbWF4UmV0cmllczogNiwgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMzAwIH0gfTtcblxuICAvKipcbiAgICogVGhlIG1vcmUgZ2VuZXJvdXMgcmV0cnkgcG9saWN5IGZvciBDbG91ZEZvcm1hdGlvbiwgd2hpY2ggaGFzIGEgMSBUUE0gbGltaXQgb24gY2VydGFpbiBBUElzLFxuICAgKiB3aGljaCBhcmUgYWJ1bmRhbnRseSB1c2VkIGZvciBkZXBsb3ltZW50IHRyYWNraW5nLCAuLi5cbiAgICpcbiAgICogU28gd2UncmUgYWxsb3dpbmcgd2F5IG1vcmUgcmV0cmllcywgYnV0IHdhaXRpbmcgYSBiaXQgbW9yZS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgY2xvdWRGb3JtYXRpb25SZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDEwLCByZXRyeURlbGF5T3B0aW9uczogeyBiYXNlOiAxXzAwMCB9IH07XG5cbiAgLyoqXG4gICAqIFNUUyBpcyB1c2VkIHRvIGNoZWNrIGNyZWRlbnRpYWwgdmFsaWRpdHksIGRvbid0IGRvIHRvbyBtYW55IHJldHJpZXMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHN0c1JldHJ5T3B0aW9ucyA9IHsgbWF4UmV0cmllczogMywgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMTAwIH0gfTtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBoYXZlIHByb29mIHRoYXQgdGhlIGNyZWRlbnRpYWxzIGhhdmUgbm90IGV4cGlyZWRcbiAgICpcbiAgICogV2UgbmVlZCB0byBkbyBzb21lIG1hbnVhbCBwbHVtYmluZyBhcm91bmQgdGhpcyBiZWNhdXNlIHRoZSBKUyBTREt2MiB0cmVhdHMgYEV4cGlyZWRUb2tlbmBcbiAgICogYXMgcmV0cmlhYmxlIGFuZCB3ZSBoYXZlIGhlZnR5IHJldHJpZXMgb24gQ0ZOIGNhbGxzIG1ha2luZyB0aGUgQ0xJIGhhbmcgZm9yIGEgZ29vZCAxNSBtaW51dGVzXG4gICAqIGlmIHRoZSBjcmVkZW50aWFscyBoYXZlIGV4cGlyZWQuXG4gICAqL1xuICBwcml2YXRlIF9jcmVkZW50aWFsc1ZhbGlkYXRlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2NyZWRlbnRpYWxzOiBBV1MuQ3JlZGVudGlhbHMsXG4gICAgcmVnaW9uOiBzdHJpbmcsXG4gICAgaHR0cE9wdGlvbnM6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge30sXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZGtPcHRpb25zOiBTZGtPcHRpb25zID0ge30pIHtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4uaHR0cE9wdGlvbnMsXG4gICAgICAuLi50aGlzLnJldHJ5T3B0aW9ucyxcbiAgICAgIGNyZWRlbnRpYWxzOiBfY3JlZGVudGlhbHMsXG4gICAgICByZWdpb24sXG4gICAgICBsb2dnZXI6IHsgbG9nOiAoLi4ubWVzc2FnZXMpID0+IG1lc3NhZ2VzLmZvckVhY2gobSA9PiB0cmFjZSgnJXMnLCBtKSkgfSxcbiAgICB9O1xuICAgIHRoaXMuY3VycmVudFJlZ2lvbiA9IHJlZ2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBhcHBlbmRDdXN0b21Vc2VyQWdlbnQodXNlckFnZW50RGF0YT86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghdXNlckFnZW50RGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRDdXN0b21Vc2VyQWdlbnQgPSB0aGlzLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ7XG4gICAgdGhpcy5jb25maWcuY3VzdG9tVXNlckFnZW50ID0gY3VycmVudEN1c3RvbVVzZXJBZ2VudFxuICAgICAgPyBgJHtjdXJyZW50Q3VzdG9tVXNlckFnZW50fSAke3VzZXJBZ2VudERhdGF9YFxuICAgICAgOiB1c2VyQWdlbnREYXRhO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUN1c3RvbVVzZXJBZ2VudCh1c2VyQWdlbnREYXRhOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB0aGlzLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQ/LnJlcGxhY2UodXNlckFnZW50RGF0YSwgJycpO1xuICB9XG5cbiAgcHVibGljIGxhbWJkYSgpOiBBV1MuTGFtYmRhIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5MYW1iZGEodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBjbG91ZEZvcm1hdGlvbigpOiBBV1MuQ2xvdWRGb3JtYXRpb24ge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkNsb3VkRm9ybWF0aW9uKHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgLi4udGhpcy5jbG91ZEZvcm1hdGlvblJldHJ5T3B0aW9ucyxcbiAgICB9KSk7XG4gIH1cblxuICBwdWJsaWMgZWMyKCk6IEFXUy5FQzIge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkVDMih0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGlhbSgpOiBBV1MuSUFNIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5JQU0odGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBzc20oKTogQVdTLlNTTSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuU1NNKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgczMoe1xuICAgIG5lZWRzTWQ1Q2hlY2tzdW1zOiBhcGlSZXF1aXJlc01kNUNoZWNrc3VtID0gZmFsc2UsXG4gIH06IFMzQ2xpZW50T3B0aW9ucyA9IHt9KTogQVdTLlMzIHtcbiAgICBjb25zdCBjb25maWcgPSB7IC4uLnRoaXMuY29uZmlnIH07XG5cbiAgICBpZiAoY3J5cHRvLmdldEZpcHMoKSAmJiBhcGlSZXF1aXJlc01kNUNoZWNrc3VtKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBkaXNhcHBlYXIgZm9yIFNES3YzOyBpbiBTREt2Mywgd2UgY2FuIGFsd2F5cyBmb3JjZSB0aGUgY2xpZW50IHRvIHVzZSBTSEEyNTYgY2hlY2tzdW1zXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIE1ENSBmb3IgaW50ZWdyaXR5IHB1cnBvc2VzOyB1bmZvcnR1bmF0ZWx5LCBpdCB0aGVyZWZvcmUgaXMgbm90IGF2YWlsYWJsZSBpbiBGSVBTIGVuYWJsZWQgZW52aXJvbm1lbnRzLicpO1xuICAgIH1cblxuICAgIGlmIChjcnlwdG8uZ2V0RmlwcygpKSB7XG4gICAgICAvLyBJbiBGSVBTIGVuYWJsZWQgZW52aXJvbm1lbnRzLCB0aGUgTUQ1IGFsZ29yaXRobSBpcyBub3QgYXZhaWxhYmxlIGZvciB1c2UgaW4gY3J5cHRvIG1vZHVsZS5cbiAgICAgIC8vIEhvd2V2ZXIgYnkgZGVmYXVsdCB0aGUgUzMgY2xpZW50IGlzIHVzaW5nIGFuIE1ENSBjaGVja3N1bSBmb3IgY29udGVudCBpbnRlZ3JpdHkgY2hlY2tpbmcuXG4gICAgICAvLyBXaGlsZSB0aGlzIHVzYWdlIGlzIHRlY2huaWNhbGx5IGFsbG93ZWQgaW4gRklQUyAoTUQ1IGlzIG9ubHkgcHJvaGliaXRlZCBmb3IgY3J5cHRvZ3JhcGhpYyB1c2UpLFxuICAgICAgLy8gaW4gcHJhY3RpY2UgaXQgaXMganVzdCBlYXNpZXIgdG8gdXNlIGFuIGFsbG93ZWQgY2hlY2tzdW0gbWVjaGFuaXNtLlxuICAgICAgLy8gV2UgYXJlIGRpc2FibGluZyB0aGUgUzMgY29udGVudCBjaGVja3N1bXMsIGFuZCBhcmUgcmUtZW5hYmxpbmcgdGhlIHJlZ3VsYXIgU2lnVjQgYm9keSBzaWduaW5nLlxuICAgICAgLy8gU2lnVjQgdXNlcyBTSEEyNTYgZm9yIHRoZWlyIGNvbnRlbnQgY2hlY2tzdW0uXG4gICAgICAvL1xuICAgICAgLy8gQXMgZmFyIGFzIHdlIGtub3csIHRoaXMgY29uZmlndXJhdGlvbiB3aWxsIHdvcmsgZm9yIG1vc3QgQVBJcyBleGNlcHQ6XG4gICAgICAvLyAtIERlbGV0ZU9iamVjdHMgKG5vdGUgdGhlIHBsdXJhbClcbiAgICAgIC8vIC0gUHV0T2JqZWN0IHRvIGEgYnVja2V0IHdpdGggT2JqZWN0IExvY2sgZW5hYmxlZC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGVzZSBBUElzIHJlZnVzZSB0byB3b3JrIHdpdGhvdXQgYSBjb250ZW50IGNoZWNrc3VtIGF0IHRoZSBTMyBsZXZlbCAoYSBTaWdWNCBjaGVja3N1bSBpcyBub3RcbiAgICAgIC8vIGdvb2QgZW5vdWdoKS4gVGhlcmUgaXMgbm8gd2F5IHRvIGdldCB0aG9zZSB0byB3b3JrIHdpdGggU0hBMjU2IGluIHRoZSBTREt2MiwgYnV0IHRoaXMgbGltaXRhdGlvblxuICAgICAgLy8gd2lsbCBiZSBhbGxldmlhdGVkIG9uY2Ugd2UgbWlncmF0ZSB0byBTREt2My5cbiAgICAgIGNvbmZpZy5zM0Rpc2FibGVCb2R5U2lnbmluZyA9IGZhbHNlO1xuICAgICAgY29uZmlnLmNvbXB1dGVDaGVja3N1bXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TMyhjb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyByb3V0ZTUzKCk6IEFXUy5Sb3V0ZTUzIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5Sb3V0ZTUzKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgZWNyKCk6IEFXUy5FQ1Ige1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkVDUih0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGVjcygpOiBBV1MuRUNTIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5FQ1ModGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBlbGJ2MigpOiBBV1MuRUxCdjIge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkVMQnYyKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgc2VjcmV0c01hbmFnZXIoKTogQVdTLlNlY3JldHNNYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TZWNyZXRzTWFuYWdlcih0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGttcygpOiBBV1MuS01TIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5LTVModGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGVwRnVuY3Rpb25zKCk6IEFXUy5TdGVwRnVuY3Rpb25zIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TdGVwRnVuY3Rpb25zKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgY29kZUJ1aWxkKCk6IEFXUy5Db2RlQnVpbGQge1xuICAgIHJldHVybiB0aGlzLndyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZyhuZXcgQVdTLkNvZGVCdWlsZCh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIGNsb3VkV2F0Y2hMb2dzKCk6IEFXUy5DbG91ZFdhdGNoTG9ncyB7XG4gICAgcmV0dXJuIHRoaXMud3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuQ2xvdWRXYXRjaExvZ3ModGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBhcHBzeW5jKCk6IEFXUy5BcHBTeW5jIHtcbiAgICByZXR1cm4gdGhpcy53cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5BcHBTeW5jKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3VycmVudEFjY291bnQoKTogUHJvbWlzZTxBY2NvdW50PiB7XG4gICAgLy8gR2V0L3JlZnJlc2ggaWYgbmVjZXNzYXJ5IGJlZm9yZSB3ZSBjYW4gYWNjZXNzIGBhY2Nlc3NLZXlJZGBcbiAgICBhd2FpdCB0aGlzLmZvcmNlQ3JlZGVudGlhbFJldHJpZXZhbCgpO1xuXG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLCBDVVJSRU5UX0FDQ09VTlRfS0VZLCAoKSA9PiBTREsuYWNjb3VudENhY2hlLmZldGNoKHRoaXMuX2NyZWRlbnRpYWxzLmFjY2Vzc0tleUlkLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIG9uZSwgcmVzb2x2ZSBmcm9tIFNUUyBhbmQgc3RvcmUgaW4gY2FjaGUuXG4gICAgICBkZWJ1ZygnTG9va2luZyB1cCBkZWZhdWx0IGFjY291bnQgSUQgZnJvbSBTVFMnKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBBV1MuU1RTKHsgLi4udGhpcy5jb25maWcsIC4uLnRoaXMuc3RzUmV0cnlPcHRpb25zIH0pLmdldENhbGxlcklkZW50aXR5KCkucHJvbWlzZSgpO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gcmVzdWx0LkFjY291bnQ7XG4gICAgICBjb25zdCBwYXJ0aXRpb24gPSByZXN1bHQuQXJuIS5zcGxpdCgnOicpWzFdO1xuICAgICAgaWYgKCFhY2NvdW50SWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVFMgZGlkblxcJ3QgcmV0dXJuIGFuIGFjY291bnQgSUQnKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdEZWZhdWx0IGFjY291bnQgSUQ6JywgYWNjb3VudElkKTtcblxuICAgICAgLy8gU2F2ZSBhbm90aGVyIFNUUyBjYWxsIGxhdGVyIGlmIHRoaXMgb25lIGFscmVhZHkgc3VjY2VlZGVkXG4gICAgICB0aGlzLl9jcmVkZW50aWFsc1ZhbGlkYXRlZCA9IHRydWU7XG4gICAgICByZXR1cm4geyBhY2NvdW50SWQsIHBhcnRpdGlvbiB9O1xuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgY3JlZGVudGlhbHNcbiAgICpcbiAgICogRG9uJ3QgdXNlIC0tIG9ubHkgdXNlZCB0byB3cml0ZSB0ZXN0cyBhcm91bmQgYXNzdW1pbmcgcm9sZXMuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgY3VycmVudENyZWRlbnRpYWxzKCk6IFByb21pc2U8QVdTLkNyZWRlbnRpYWxzPiB7XG4gICAgYXdhaXQgdGhpcy5mb3JjZUNyZWRlbnRpYWxSZXRyaWV2YWwoKTtcbiAgICByZXR1cm4gdGhpcy5fY3JlZGVudGlhbHM7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2UgcmV0cmlldmFsIG9mIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIFJlbGV2YW50IGlmIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBBc3N1bWVSb2xlIGNyZWRlbnRpYWxzIC0tIGRvIHRoZSBhY3R1YWxcbiAgICogbG9va3VwLCBhbmQgdHJhbnNsYXRlIGFueSBlcnJvciBpbnRvIGEgdXNlZnVsIGVycm9yIG1lc3NhZ2UgKHRha2luZyBpbnRvXG4gICAqIGFjY291bnQgY3JlZGVudGlhbCBwcm92ZW5hbmNlKS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JjZUNyZWRlbnRpYWxSZXRyaWV2YWwoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWRlbnRpYWxzLmdldFByb21pc2UoKTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChpc1VucmVjb3ZlcmFibGVBd3NFcnJvcihlKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IHJlYXNvbiB0aGlzIHdvdWxkIGZhaWwgaXMgaWYgaXQgd2FzIGFuIEFzc3VtUm9sZS4gT3RoZXJ3aXNlLFxuICAgICAgLy8gcmVhZGluZyBmcm9tIGFuIElOSSBmaWxlIG9yIHJlYWRpbmcgZW52IHZhcmlhYmxlcyBpcyB1bmxpa2VseSB0byBmYWlsLlxuICAgICAgZGVidWcoYEFzc3VtaW5nIHJvbGUgZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICdDb3VsZCBub3QgYXNzdW1lIHJvbGUgaW4gdGFyZ2V0IGFjY291bnQnLFxuICAgICAgICAuLi50aGlzLnNka09wdGlvbnMuYXNzdW1lUm9sZUNyZWRlbnRpYWxzU291cmNlRGVzY3JpcHRpb25cbiAgICAgICAgICA/IFtgdXNpbmcgJHt0aGlzLnNka09wdGlvbnMuYXNzdW1lUm9sZUNyZWRlbnRpYWxzU291cmNlRGVzY3JpcHRpb259YF1cbiAgICAgICAgICA6IFtdLFxuICAgICAgICBlLm1lc3NhZ2UsXG4gICAgICAgICcuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdCB0aGlzIHJvbGUgZXhpc3RzIGluIHRoZSBhY2NvdW50LiBJZiBpdCBkb2VzblxcJ3QgZXhpc3QsIChyZSktYm9vdHN0cmFwIHRoZSBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ3dpdGggdGhlIHJpZ2h0IFxcJy0tdHJ1c3RcXCcsIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGUgQ0RLIENMSS4nLFxuICAgICAgXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHN1cmUgdGhlIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBub3QgZXhwaXJlZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHZhbGlkYXRlQ3JlZGVudGlhbHMoKSB7XG4gICAgaWYgKHRoaXMuX2NyZWRlbnRpYWxzVmFsaWRhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgbmV3IEFXUy5TVFMoeyAuLi50aGlzLmNvbmZpZywgLi4udGhpcy5zdHNSZXRyeU9wdGlvbnMgfSkuZ2V0Q2FsbGVySWRlbnRpdHkoKS5wcm9taXNlKCk7XG4gICAgdGhpcy5fY3JlZGVudGlhbHNWYWxpZGF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgcHVibGljIGdldEVuZHBvaW50U3VmZml4KHJlZ2lvbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVnaW9uVXRpbC5nZXRFbmRwb2ludFN1ZmZpeChyZWdpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHdyYXBwaW5nIG9iamVjdCBmb3IgdGhlIHVuZGVybHlpbmcgc2VydmljZSBvYmplY3RcbiAgICpcbiAgICogUmVzcG9uZHMgdG8gZmFpbHVyZXMgaW4gdGhlIHVuZGVybHlpbmcgc2VydmljZSBjYWxscywgaW4gdHdvIGRpZmZlcmVudFxuICAgKiB3YXlzOlxuICAgKlxuICAgKiAtIFdoZW4gZXJyb3JzIGFyZSBlbmNvdW50ZXJlZCwgbG9nIHRoZSBmYWlsaW5nIGNhbGwgYW5kIHRoZSBlcnJvciB0aGF0XG4gICAqICAgaXQgdHJpZ2dlcmVkIChhdCBkZWJ1ZyBsZXZlbCkuIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGxhY2sgb2ZcbiAgICogICBzdGFjayB0cmFjZXMgaW4gTm9kZUpTIG90aGVyd2lzZSBtYWtlcyBpdCB2ZXJ5IGhhcmQgdG8gc3VzcyBvdXQgd2hlcmVcbiAgICogICBhIGNlcnRhaW4gQVdTIGVycm9yIG9jY3VycmVkLlxuICAgKiAtIFRoZSBKUyBTREsgaGFzIGEgZnVubnkgYnVzaW5lc3Mgb2Ygd3JhcHBpbmcgYW55IGNyZWRlbnRpYWwtYmFzZWQgZXJyb3JcbiAgICogICBpbiBhIHN1cGVyLWdlbmVyaWMgKGFuZCBpbiBvdXIgY2FzZSB3cm9uZykgZXhjZXB0aW9uLiBJZiB3ZSB0aGVuIHVzZSBhXG4gICAqICAgJ0NoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzJyBhbmQgdGhlIHRhcmdldCByb2xlIGRvZXNuJ3QgZXhpc3QsXG4gICAqICAgdGhlIGVycm9yIG1lc3NhZ2UgdGhhdCBzaG93cyB1cCBieSBkZWZhdWx0IGlzIHN1cGVyIG1pc2xlYWRpbmdcbiAgICogICAoaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3Mtc2RrLWpzL2lzc3Vlcy8zMjcyKS4gV2UgY2FuIGZpeCB0aGlzIGJlY2F1c2VcbiAgICogICB0aGUgZXhjZXB0aW9uIGNvbnRhaW5zIHRoZSBcImlubmVyIGV4Y2VwdGlvblwiLCBzbyB3ZSB1bndyYXAgYW5kIHRocm93XG4gICAqICAgdGhlIGNvcnJlY3QgZXJyb3IgKFwiY2Fubm90IGFzc3VtZSByb2xlXCIpLlxuICAgKlxuICAgKiBUaGUgd3JhcHBpbmcgYnVzaW5lc3MgYmVsb3cgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCB0aGFuIHlvdSdkIHRoaW5rXG4gICAqIGJlY2F1c2Ugd2UgbXVzdCBob29rIGludG8gdGhlIGBwcm9taXNlKClgIG1ldGhvZCBvZiB0aGUgb2JqZWN0IHRoYXQncyBiZWluZ1xuICAgKiByZXR1cm5lZCBmcm9tIHRoZSBtZXRob2RzIG9mIHRoZSBvYmplY3QgdGhhdCB3ZSB3cmFwLCBzbyB0aGVyZSdzIHR3b1xuICAgKiBsZXZlbHMgb2Ygd3JhcHBpbmcgZ29pbmcgb24sIGFuZCBhbHNvIHNvbWUgZXhjZXB0aW9ucyB0byB0aGUgd3JhcHBpbmcgbWFnaWMuXG4gICAqL1xuICBwcml2YXRlIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZzxBIGV4dGVuZHMgb2JqZWN0PihzZXJ2aWNlT2JqZWN0OiBBKTogQSB7XG4gICAgY29uc3QgY2xhc3NPYmplY3QgPSBzZXJ2aWNlT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiBuZXcgUHJveHkoc2VydmljZU9iamVjdCwge1xuICAgICAgZ2V0KG9iajogQSwgcHJvcDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHJlYWwgPSAob2JqIGFzIGFueSlbcHJvcF07XG4gICAgICAgIC8vIFRoaW5ncyB3ZSBkb24ndCB3YW50IHRvIGludGVyY2VwdDpcbiAgICAgICAgLy8gLSBBbnl0aGluZyB0aGF0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIC0gJ2NvbnN0cnVjdG9yJywgczMudXBsb2FkKCkgd2lsbCB1c2UgdGhpcyB0byBkbyBzb21lIG1hZ2ljIGFuZCB3ZSBuZWVkIHRoZSB1bmRlcmx5aW5nIGNvbnN0cnVjdG9yLlxuICAgICAgICAvLyAtIEFueSBtZXRob2QgdGhhdCdzIG5vdCBvbiB0aGUgc2VydmljZSBjbGFzcyAoZG8gbm90IGludGVyY2VwdCAnbWFrZVJlcXVlc3QnIGFuZCBvdGhlciBoZWxwZXJzKS5cbiAgICAgICAgaWYgKHByb3AgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWNsYXNzT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc0Z1bmN0aW9uKHJlYWwpKSB7IHJldHVybiByZWFsOyB9XG5cbiAgICAgICAgLy8gTk9URTogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24oKSBhbmQgbm90IGFuICgpID0+IHtcbiAgICAgICAgLy8gYmVjYXVzZSBJIG5lZWQgJ3RoaXMnIHRvIGJlIGR5bmFtaWNhbGx5IGJvdW5kIGFuZCBub3Qgc3RhdGljYWxseSBib3VuZC5cbiAgICAgICAgLy8gSWYgeW91ciBsaW50ZXIgY29tcGxhaW5zIGRvbid0IGxpc3RlbiB0byBpdCFcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRoaXM6IGFueSkge1xuICAgICAgICAgIC8vIENhbGwgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb24uIElmIGl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBwcm9taXNlKClcbiAgICAgICAgICAvLyBtZXRob2Qgb24gaXQsIHdyYXAgdGhhdCAncHJvbWlzZScgbWV0aG9kLlxuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZWFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgLy8gRG9uJ3QgaW50ZXJjZXB0IHVubGVzcyB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGEgJy5wcm9taXNlKCknIG1ldGhvZC5cbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0JyB8fCAhcmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlOyB9XG4gICAgICAgICAgaWYgKCEoJ3Byb21pc2UnIGluIHJlc3BvbnNlKSkgeyByZXR1cm4gcmVzcG9uc2U7IH1cblxuICAgICAgICAgIC8vIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvbWlzZSBtZXRob2QgcmVwbGFjZWQgd2l0aCBhIHdyYXBwZXIgd2hpY2ggd2lsbFxuICAgICAgICAgIC8vIGRvIGFkZGl0aW9uYWwgdGhpbmdzIHRvIGVycm9ycy5cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHJlc3BvbnNlKSwge1xuICAgICAgICAgICAgcHJvbWlzZSgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnByb21pc2UoKS5jYXRjaCgoZTogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGUgPSBzZWxmLm1ha2VEZXRhaWxlZEV4Y2VwdGlvbihlKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgQ2FsbCBmYWlsZWQ6ICR7cHJvcH0oJHtKU09OLnN0cmluZ2lmeShhcmdzWzBdKX0pID0+ICR7ZS5tZXNzYWdlfSAoY29kZT0ke2UuY29kZX0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyAvLyBSZS0ndGhyb3cnIHRoZSBuZXcgZXJyb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IGEgbW9yZSBkZXRhaWxlZCBlcnJvciBvdXQgb2YgYSBnZW5lcmljIGVycm9yIGlmIHdlIGNhblxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGFuIGVycm9yIGFib3V0IEFzc3VtaW5nIFJvbGVzLCBhZGQgaW4gdGhlIGNvbnRleHQgc2hvd2luZyB0aGVcbiAgICogY2hhaW4gb2YgY3JlZGVudGlhbHMgd2UgdXNlZCB0byB0cnkgdG8gYXNzdW1lIHRoZSByb2xlLlxuICAgKi9cbiAgcHJpdmF0ZSBtYWtlRGV0YWlsZWRFeGNlcHRpb24oZTogRXJyb3IpOiBFcnJvciB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc3VwZXItZ2VuZXJpYyBcInNvbWV0aGluZydzIHdyb25nXCIgZXJyb3IgdGhhdCB0aGUgSlMgU0RLIHdyYXBzIG90aGVyIGVycm9ycyBpbi5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1zZGstanMvYmxvYi9mMGFjMmU1MzQ1N2M3NTEyODgzZDA2NzcwMTNlYWNhYWQ2Y2Q4YTE5L2xpYi9ldmVudF9saXN0ZW5lcnMuanMjTDg0XG4gICAgaWYgKHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGUubWVzc2FnZS5zdGFydHNXaXRoKCdNaXNzaW5nIGNyZWRlbnRpYWxzIGluIGNvbmZpZycpKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IChlIGFzIGFueSkub3JpZ2luYWxFcnJvcjtcbiAgICAgIGlmIChvcmlnaW5hbCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBTREsgZG9lcyBhICd1dGlsLmNvcHknLCB0aGV5IGxvc2UgdGhlIEVycm9yLW5lc3Mgb2YgdGhlIGlubmVyIGVycm9yXG4gICAgICAgIC8vICh0aGV5IGNvcHkgdGhlIEVycm9yJ3MgcHJvcGVydGllcyBpbnRvIGEgcGxhaW4gb2JqZWN0KSBzbyBtYWtlIGl0IGFuIEVycm9yIG9iamVjdCBhZ2Fpbi5cbiAgICAgICAgZSA9IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCksIG9yaWdpbmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgZXJyb3IgbWlnaHQgc3RpbGwgYmUgYSBnZW5lcmljIFwiQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMgZmFpbGVkXCJcbiAgICAvLyBlcnJvciB3aGljaCB3cmFwcyB0aGUgUkVBTCBlcnJvciAoQXNzdW1lUm9sZSBmYWlsZWQpLiBXZSdyZSBnb2luZyB0byByZXBsYWNlIHRoZSBlcnJvclxuICAgIC8vIG1lc3NhZ2Ugd2l0aCBvbmUgdGhhdCdzIG1vcmUgbGlrZWx5IHRvIGhlbHAgdXNlcnMsIGFuZCB0ZWxsIHRoZW0gdGhlIG1vc3QgcHJvYmFibGVcbiAgICAvLyBmaXggKGJvb3RzdHJhcHBpbmcpLiBUaGUgdW5kZXJseWluZyBzZXJ2aWNlIGNhbGwgZmFpbHVyZSB3aWxsIGJlIGFwcGVuZGVkIGJlbG93LlxuICAgIGlmIChlLm1lc3NhZ2UgPT09ICdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tIENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzJykge1xuICAgICAgZS5tZXNzYWdlID0gW1xuICAgICAgICAnQ291bGQgbm90IGFzc3VtZSByb2xlIGluIHRhcmdldCBhY2NvdW50JyxcbiAgICAgICAgLi4udGhpcy5zZGtPcHRpb25zLmFzc3VtZVJvbGVDcmVkZW50aWFsc1NvdXJjZURlc2NyaXB0aW9uXG4gICAgICAgICAgPyBbYHVzaW5nICR7dGhpcy5zZGtPcHRpb25zLmFzc3VtZVJvbGVDcmVkZW50aWFsc1NvdXJjZURlc2NyaXB0aW9ufWBdXG4gICAgICAgICAgOiBbXSxcbiAgICAgICAgJyhkaWQgeW91IGJvb3RzdHJhcCB0aGUgZW52aXJvbm1lbnQgd2l0aCB0aGUgcmlnaHQgXFwnLS10cnVzdFxcJ3M/KScsXG4gICAgICBdLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBtZXNzYWdlIG9uIHRoaXMgZXJyb3Igd2l0aCBhIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubmVyIGVycm9yIG1lc3NhZ2VzLlxuICAgIC8vIE11c3QgbW9yZSBjbGVhciB3aGF0J3MgZ29pbmcgb24gdGhhdCB3YXkuXG4gICAgZS5tZXNzYWdlID0gYWxsQ2hhaW5lZEV4Y2VwdGlvbk1lc3NhZ2VzKGUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmNvbnN0IENVUlJFTlRfQUNDT1VOVF9LRVkgPSBTeW1ib2woJ2N1cnJlbnRfYWNjb3VudF9rZXknKTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4OiBhbnkpOiB4IGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IHtcbiAgcmV0dXJuIHggJiYge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbmNhdGVuYXRlZCBtZXNzYWdlIG9mIGFsbCBleGNlcHRpb25zIGluIHRoZSBBV1MgZXhjZXB0aW9uIGNoYWluXG4gKi9cbmZ1bmN0aW9uIGFsbENoYWluZWRFeGNlcHRpb25NZXNzYWdlcyhlOiBFcnJvciB8IHVuZGVmaW5lZCkge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICB3aGlsZSAoZSkge1xuICAgIHJldC5wdXNoKGUubWVzc2FnZSk7XG4gICAgZSA9IChlIGFzIGFueSkub3JpZ2luYWxFcnJvcjtcbiAgfVxuICByZXR1cm4gcmV0LmpvaW4oJzogJyk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYW4gZXJyb3Igc2hvdWxkIG5vdCBiZSByZWNvdmVyZWQgZnJvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbnJlY292ZXJhYmxlQXdzRXJyb3IoZTogRXJyb3IpIHtcbiAgcmV0dXJuIChlIGFzIGFueSkuY29kZSA9PT0gJ0V4cGlyZWRUb2tlbic7XG59XG4iXX0=