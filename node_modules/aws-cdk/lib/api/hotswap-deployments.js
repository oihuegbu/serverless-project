"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = tryHotswapDeployment;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const logging_1 = require("../logging");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
// Must use a require() otherwise esbuild complains about calling a namespace
// eslint-disable-next-line @typescript-eslint/no-require-imports
const pLimit = require('p-limit');
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::ApiKey': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': async (logicalId, change, evaluateCfnTemplate) => {
        // If the policy is for a S3BucketDeploymentChange, we can ignore the change
        if (await (0, s3_bucket_deployments_1.skipChangeForS3DeployCustomResourcePolicy)(logicalId, change, evaluateCfnTemplate)) {
            return [];
        }
        return (0, common_1.reportNonHotswappableResource)(change, 'This resource type is not supported for hotswap deployments');
    },
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment, short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact, hotswapMode, hotswapPropertyOverrides) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stackArtifact, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        sdk,
        nestedStacks: currentTemplate.nestedStacks,
    });
    const stackChanges = cfn_diff.fullDiff(currentTemplate.deployedRootTemplate, stackArtifact.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStacks, hotswapPropertyOverrides);
    logNonHotswappableChanges(nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === common_1.HotswapMode.FALL_BACK) {
        if (nonHotswappableChanges.length > 0) {
            return undefined;
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { type: 'did-deploy-stack', noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames, hotswapPropertyOverrides) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk, hotswapPropertyOverrides);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate, hotswapPropertyOverrides));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        // Constant set of promises per resource
        // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable ?
                hotswappableResources.push(propertyResult) :
                nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackTemplates, evaluateCfnTemplate, sdk, hotswapPropertyOverrides) {
    const nestedStack = nestedStackTemplates[logicalId];
    if (!nestedStack.physicalName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [{
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                }],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStack.physicalName, nestedStack.generatedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.fullDiff(nestedStackTemplates[logicalId].deployedTemplate, nestedStackTemplates[logicalId].generatedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackTemplates[logicalId].nestedStackTemplates, hotswapPropertyOverrides);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (change.newValue?.Type !== change.oldValue?.Type) {
        return {
            hotswappable: false,
            resourceType: change.newValue?.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        (0, logging_1.print)(`\n${common_1.ICON} hotswapping resources:`);
    }
    const limit = pLimit(10);
    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
    return Promise.all(hotswappableChanges.map(hotswapOperation => limit(() => {
        return applyHotswappableChange(sdk, hotswapOperation);
    })));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`   ${common_1.ICON} %s`, chalk.bold(name));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    await hotswapOperation.apply(sdk);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function logNonHotswappableChanges(nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback'));
    }
    else {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:'));
    }
    for (const change of nonHotswappableChanges) {
        change.rejectedChanges.length > 0 ?
            (0, logging_1.print)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason)) :
            (0, logging_1.print)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason));
    }
    (0, logging_1.print)(''); // newline
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFnRUEsb0RBMkNDO0FBM0dELHlEQUF5RDtBQUV6RCwrQkFBK0I7QUFDL0IseUNBQXFEO0FBRXJELHlGQUFvRjtBQUNwRix3Q0FBbUM7QUFDbkMsbUZBQWtGO0FBQ2xGLHVFQUFxRjtBQUNyRiw2Q0FBbVE7QUFDblEseURBQXdFO0FBQ3hFLGlFQUFnRjtBQUNoRiwyRUFBb0k7QUFDcEkseUZBQTBGO0FBQzFGLGlFQUFtRztBQUduRyw2RUFBNkU7QUFDN0UsaUVBQWlFO0FBQ2pFLE1BQU0sTUFBTSxHQUE2QixPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFTNUQsTUFBTSxrQkFBa0IsR0FBdUM7SUFDN0QsU0FBUztJQUNULHVCQUF1QixFQUFFLHFEQUFrQztJQUMzRCxzQkFBc0IsRUFBRSxxREFBa0M7SUFDMUQsb0JBQW9CLEVBQUUscURBQWtDO0lBRXhELFVBQVU7SUFDVix3QkFBd0IsRUFBRSx1REFBMkI7SUFDckQscUNBQXFDLEVBQUUsdURBQTJCO0lBQ2xFLDZCQUE2QixFQUFFLHVEQUEyQjtJQUMxRCxzQkFBc0IsRUFBRSx1REFBMkI7SUFFbkQsMEJBQTBCLEVBQUUsNkNBQThCO0lBQzFELHlCQUF5QixFQUFFLDBEQUFvQztJQUMvRCxrQ0FBa0MsRUFBRSwrREFBZ0M7SUFDcEUsNkJBQTZCLEVBQUUsOERBQXNDO0lBQ3JFLGtCQUFrQixFQUFFLEtBQUssRUFDdkIsU0FBaUIsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRCxFQUM3RSxFQUFFO1FBQ2hDLDRFQUE0RTtRQUM1RSxJQUFJLE1BQU0sSUFBQSxpRUFBeUMsRUFBQyxTQUFTLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixDQUFDLEVBQUUsQ0FBQztZQUM1RixPQUFPLEVBQUUsQ0FBQztRQUNaLENBQUM7UUFFRCxPQUFPLElBQUEs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QUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDck0sSUFBQSxlQUFLLEVBQUMseUNBQXlDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM5SSxDQUFDO0lBRUQsSUFBQSxlQUFLLEVBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBJU0RLLCBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgU3VjY2Vzc2Z1bERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2FwcHN5bmMtbWFwcGluZy10ZW1wbGF0ZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2NvZGUtYnVpbGQtcHJvamVjdHMnO1xuaW1wb3J0IHsgSUNPTiwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE1vZGUsIEhvdHN3YXBwYWJsZUNoYW5nZSwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlLCBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcywgQ2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcywgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlLCByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZSB9IGZyb20gJy4vaG90c3dhcC9jb21tb24nO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2Vjcy1zZXJ2aWNlcyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL2xhbWJkYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgc2tpcENoYW5nZUZvclMzRGVwbG95Q3VzdG9tUmVzb3VyY2VQb2xpY3ksIGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL3MzLWJ1Y2tldC1kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9zdGVwZnVuY3Rpb25zLXN0YXRlLW1hY2hpbmVzJztcbmltcG9ydCB7IE5lc3RlZFN0YWNrVGVtcGxhdGVzLCBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyB9IGZyb20gJy4vbmVzdGVkLXN0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjayB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbic7XG5cbi8vIE11c3QgdXNlIGEgcmVxdWlyZSgpIG90aGVyd2lzZSBlc2J1aWxkIGNvbXBsYWlucyBhYm91dCBjYWxsaW5nIGEgbmFtZXNwYWNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgcExpbWl0OiB0eXBlb2YgaW1wb3J0KCdwLWxpbWl0JykgPSByZXF1aXJlKCdwLWxpbWl0Jyk7XG5cbnR5cGUgSG90c3dhcERldGVjdG9yID0gKFxuICBsb2dpY2FsSWQ6IHN0cmluZyxcbiAgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbiAgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzOiBIb3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4pID0+IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD47XG5cbmNvbnN0IFJFU09VUkNFX0RFVEVDVE9SUzogeyBba2V5OiBzdHJpbmddOiBIb3Rzd2FwRGV0ZWN0b3IgfSA9IHtcbiAgLy8gTGFtYmRhXG4gICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OlZlcnNpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OkFsaWFzJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcblxuICAvLyBBcHBTeW5jXG4gICdBV1M6OkFwcFN5bmM6OlJlc29sdmVyJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpGdW5jdGlvbkNvbmZpZ3VyYXRpb24nOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkdyYXBoUUxTY2hlbWEnOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkFwaUtleSc6IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSxcblxuICAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJzogaXNIb3Rzd2FwcGFibGVFY3NTZXJ2aWNlQ2hhbmdlLFxuICAnQVdTOjpDb2RlQnVpbGQ6OlByb2plY3QnOiBpc0hvdHN3YXBwYWJsZUNvZGVCdWlsZFByb2plY3RDaGFuZ2UsXG4gICdBV1M6OlN0ZXBGdW5jdGlvbnM6OlN0YXRlTWFjaGluZSc6IGlzSG90c3dhcHBhYmxlU3RhdGVNYWNoaW5lQ2hhbmdlLFxuICAnQ3VzdG9tOjpDREtCdWNrZXREZXBsb3ltZW50JzogaXNIb3Rzd2FwcGFibGVTM0J1Y2tldERlcGxveW1lbnRDaGFuZ2UsXG4gICdBV1M6OklBTTo6UG9saWN5JzogYXN5bmMgKFxuICAgIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICApOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+ID0+IHtcbiAgICAvLyBJZiB0aGUgcG9saWN5IGlzIGZvciBhIFMzQnVja2V0RGVwbG95bWVudENoYW5nZSwgd2UgY2FuIGlnbm9yZSB0aGUgY2hhbmdlXG4gICAgaWYgKGF3YWl0IHNraXBDaGFuZ2VGb3JTM0RlcGxveUN1c3RvbVJlc291cmNlUG9saWN5KGxvZ2ljYWxJZCwgY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiByZXBvcnROb25Ib3Rzd2FwcGFibGVSZXNvdXJjZShjaGFuZ2UsICdUaGlzIHJlc291cmNlIHR5cGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgaG90c3dhcCBkZXBsb3ltZW50cycpO1xuICB9LFxuXG4gICdBV1M6OkNESzo6TWV0YWRhdGEnOiBhc3luYyAoKSA9PiBbXSxcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhIGhvdHN3YXAgZGVwbG95bWVudCwgc2hvcnQtY2lyY3VpdGluZyBDbG91ZEZvcm1hdGlvbiBpZiBwb3NzaWJsZS5cbiAqIElmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHNob3J0LWNpcmN1aXQgdGhlIGRlcGxveW1lbnRcbiAqIChiZWNhdXNlIHRoZSBDREsgU3RhY2sgY29udGFpbnMgY2hhbmdlcyB0aGF0IGNhbm5vdCBiZSBkZXBsb3llZCB3aXRob3V0IENsb3VkRm9ybWF0aW9uKSxcbiAqIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cnlIb3Rzd2FwRGVwbG95bWVudChcbiAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLCBhc3NldFBhcmFtczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgY2xvdWRGb3JtYXRpb25TdGFjazogQ2xvdWRGb3JtYXRpb25TdGFjaywgc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBob3Rzd2FwTW9kZTogSG90c3dhcE1vZGUsIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKTogUHJvbWlzZTxTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfCB1bmRlZmluZWQ+IHtcbiAgLy8gcmVzb2x2ZSB0aGUgZW52aXJvbm1lbnQsIHNvIHdlIGNhbiBzdWJzdGl0dXRlIHRoaW5ncyBsaWtlIEFXUzo6UmVnaW9uIGluIENGTiBleHByZXNzaW9uc1xuICBjb25zdCByZXNvbHZlZEVudiA9IGF3YWl0IHNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFja0FydGlmYWN0LmVudmlyb25tZW50KTtcbiAgLy8gY3JlYXRlIGEgbmV3IFNESyB1c2luZyB0aGUgQ0xJIGNyZWRlbnRpYWxzLCBiZWNhdXNlIHRoZSBkZWZhdWx0IG9uZSB3aWxsIG5vdCB3b3JrIGZvciBuZXctc3R5bGUgc3ludGhlc2lzIC1cbiAgLy8gaXQgYXNzdW1lcyB0aGUgYm9vdHN0cmFwIGRlcGxveSBSb2xlLCB3aGljaCBkb2Vzbid0IGhhdmUgcGVybWlzc2lvbnMgdG8gdXBkYXRlIExhbWJkYSBmdW5jdGlvbnNcbiAgY29uc3Qgc2RrID0gKGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52LCBNb2RlLkZvcldyaXRpbmcpKS5zZGs7XG5cbiAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgbG9hZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3Moc3RhY2tBcnRpZmFjdCwgc2RrKTtcblxuICBjb25zdCBldmFsdWF0ZUNmblRlbXBsYXRlID0gbmV3IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSh7XG4gICAgc3RhY2tOYW1lOiBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSxcbiAgICB0ZW1wbGF0ZTogc3RhY2tBcnRpZmFjdC50ZW1wbGF0ZSxcbiAgICBwYXJhbWV0ZXJzOiBhc3NldFBhcmFtcyxcbiAgICBhY2NvdW50OiByZXNvbHZlZEVudi5hY2NvdW50LFxuICAgIHJlZ2lvbjogcmVzb2x2ZWRFbnYucmVnaW9uLFxuICAgIHBhcnRpdGlvbjogKGF3YWl0IHNkay5jdXJyZW50QWNjb3VudCgpKS5wYXJ0aXRpb24sXG4gICAgdXJsU3VmZml4OiAocmVnaW9uKSA9PiBzZGsuZ2V0RW5kcG9pbnRTdWZmaXgocmVnaW9uKSxcbiAgICBzZGssXG4gICAgbmVzdGVkU3RhY2tzOiBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tzLFxuICB9KTtcblxuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5mdWxsRGlmZihjdXJyZW50VGVtcGxhdGUuZGVwbG95ZWRSb290VGVtcGxhdGUsIHN0YWNrQXJ0aWZhY3QudGVtcGxhdGUpO1xuICBjb25zdCB7IGhvdHN3YXBwYWJsZUNoYW5nZXMsIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMgfSA9IGF3YWl0IGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICAgIHN0YWNrQ2hhbmdlcywgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgc2RrLCBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tzLCBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMsXG4gICk7XG5cbiAgbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLCBob3Rzd2FwTW9kZSk7XG5cbiAgLy8gcHJlc2VydmUgY2xhc3NpYyBob3Rzd2FwIGJlaGF2aW9yXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gSG90c3dhcE1vZGUuRkFMTF9CQUNLKSB7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBhcHBseSB0aGUgc2hvcnQtY2lyY3VpdGFibGUgY2hhbmdlc1xuICBhd2FpdCBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrLCBob3Rzd2FwcGFibGVDaGFuZ2VzKTtcblxuICByZXR1cm4geyB0eXBlOiAnZGlkLWRlcGxveS1zdGFjaycsIG5vT3A6IGhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwLCBzdGFja0FybjogY2xvdWRGb3JtYXRpb25TdGFjay5zdGFja0lkLCBvdXRwdXRzOiBjbG91ZEZvcm1hdGlvblN0YWNrLm91dHB1dHMgfTtcbn1cblxuLyoqXG4gKiBDbGFzc2lmaWVzIGFsbCBjaGFuZ2VzIHRvIGFsbCByZXNvdXJjZXMgYXMgZWl0aGVyIGhvdHN3YXBwYWJsZSBvciBub3QuXG4gKiBNZXRhZGF0YSBjaGFuZ2VzIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBsaXN0IG9mIChub24paG90c3dhcHBhYmxlIHJlc291cmNlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xhc3NpZnlSZXNvdXJjZUNoYW5nZXMoXG4gIHN0YWNrQ2hhbmdlczogY2ZuX2RpZmYuVGVtcGxhdGVEaWZmLFxuICBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4gIHNkazogSVNESyxcbiAgbmVzdGVkU3RhY2tOYW1lczogeyBbbmVzdGVkU3RhY2tOYW1lOiBzdHJpbmddOiBOZXN0ZWRTdGFja1RlbXBsYXRlcyB9LFxuICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXM6IEhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbik6IFByb21pc2U8Q2xhc3NpZmllZFJlc291cmNlQ2hhbmdlcz4ge1xuICBjb25zdCByZXNvdXJjZURpZmZlcmVuY2VzID0gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlcyk7XG5cbiAgY29uc3QgcHJvbWlzZXM6IEFycmF5PCgpID0+IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4+ID0gW107XG4gIGNvbnN0IGhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxIb3Rzd2FwcGFibGVDaGFuZ2U+KCk7XG4gIGNvbnN0IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyA9IG5ldyBBcnJheTxOb25Ib3Rzd2FwcGFibGVDaGFuZ2U+KCk7XG4gIGZvciAoY29uc3QgbG9naWNhbElkIG9mIE9iamVjdC5rZXlzKHN0YWNrQ2hhbmdlcy5vdXRwdXRzLmNoYW5nZXMpKSB7XG4gICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goe1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogJ291dHB1dCB3YXMgY2hhbmdlZCcsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVzb3VyY2VUeXBlOiAnU3RhY2sgT3V0cHV0JyxcbiAgICB9KTtcbiAgfVxuICAvLyBnYXRoZXIgdGhlIHJlc3VsdHMgb2YgdGhlIGRldGVjdG9yIGZ1bmN0aW9uc1xuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIGNoYW5nZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzb3VyY2VEaWZmZXJlbmNlcykpIHtcbiAgICBpZiAoY2hhbmdlLm5ld1ZhbHVlPy5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snICYmIGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSA9PT0gJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJykge1xuICAgICAgY29uc3QgbmVzdGVkSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gYXdhaXQgZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBuZXN0ZWRTdGFja05hbWVzLFxuICAgICAgICBldmFsdWF0ZUNmblRlbXBsYXRlLFxuICAgICAgICBzZGssXG4gICAgICAgIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlcyxcbiAgICAgICk7XG4gICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMuaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG4gICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCguLi5uZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMubm9uSG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSA9IGlzQ2FuZGlkYXRlRm9ySG90c3dhcHBpbmcoY2hhbmdlLCBsb2dpY2FsSWQpO1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gcnVuIHRoaXMgdGhyb3VnaCB0aGUgZGV0ZWN0b3IgZnVuY3Rpb25zLCB3ZSBjYW4gYWxyZWFkeSBqdWRnZSB0aGlzXG4gICAgaWYgKCdob3Rzd2FwcGFibGUnIGluIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSkge1xuICAgICAgaWYgKCFob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUuaG90c3dhcHBhYmxlKSB7XG4gICAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc291cmNlVHlwZTogc3RyaW5nID0gaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLm5ld1ZhbHVlLlR5cGU7XG4gICAgaWYgKHJlc291cmNlVHlwZSBpbiBSRVNPVVJDRV9ERVRFQ1RPUlMpIHtcbiAgICAgIC8vIHJ1biBkZXRlY3RvciBmdW5jdGlvbnMgbGF6aWx5IHRvIHByZXZlbnQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uc1xuICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PiBSRVNPVVJDRV9ERVRFQ1RPUlNbcmVzb3VyY2VUeXBlXShsb2dpY2FsSWQsIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgaG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMsIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgdW5kZWZpbmVkLCAnVGhpcyByZXNvdXJjZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGhvdHN3YXAgZGVwbG95bWVudHMnKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGFsbCBkZXRlY3RvciByZXN1bHRzXG4gIGNvbnN0IGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzOiBBcnJheTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiA9IFtdO1xuICBmb3IgKGNvbnN0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMgb2YgcHJvbWlzZXMpIHtcbiAgICAvLyBDb25zdGFudCBzZXQgb2YgcHJvbWlzZXMgcGVyIHJlc291cmNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgY29uc3QgaG90c3dhcERldGVjdGlvblJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChhd2FpdCBkZXRlY3RvclJlc3VsdFByb21pc2VzKCkpO1xuICAgIGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzLnB1c2goaG90c3dhcERldGVjdGlvblJlc3VsdHMpO1xuICB9XG5cbiAgZm9yIChjb25zdCByZXNvdXJjZURldGVjdGlvblJlc3VsdHMgb2YgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5UmVzdWx0IG9mIHJlc291cmNlRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgICAgcHJvcGVydHlSZXN1bHQuaG90c3dhcHBhYmxlID9cbiAgICAgICAgaG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2gocHJvcGVydHlSZXN1bHQpIDpcbiAgICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2gocHJvcGVydHlSZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaG90c3dhcHBhYmxlQ2hhbmdlczogaG90c3dhcHBhYmxlUmVzb3VyY2VzLFxuICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBjaGFuZ2VzIHRvIHJlc291cmNlcyBpbiB0aGUgZ2l2ZW4gU3RhY2suXG4gKlxuICogQHBhcmFtIHN0YWNrQ2hhbmdlcyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgY2hhbmdlcyB0byBhIGdpdmVuIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIGdldFN0YWNrUmVzb3VyY2VEaWZmZXJlbmNlcyhzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZik6IHsgW2xvZ2ljYWxJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0ge1xuICAvLyB3ZSBuZWVkIHRvIGNvbGxhcHNlIGxvZ2ljYWwgSUQgcmVuYW1lIGNoYW5nZXMgaW50byBvbmUgY2hhbmdlLFxuICAvLyBhcyB0aGV5IGFyZSByZXByZXNlbnRlZCBpbiBzdGFja0NoYW5nZXMgYXMgYSBwYWlyIG9mIHR3byBjaGFuZ2VzOiBvbmUgYWRkaXRpb24gYW5kIG9uZSByZW1vdmFsXG4gIGNvbnN0IGFsbFJlc291cmNlQ2hhbmdlczogeyBbbG9nSWQ6IHN0cmluZ106IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSB9ID0gc3RhY2tDaGFuZ2VzLnJlc291cmNlcy5jaGFuZ2VzO1xuICBjb25zdCBhbGxSZW1vdmFsQ2hhbmdlcyA9IGZpbHRlckRpY3QoYWxsUmVzb3VyY2VDaGFuZ2VzLCByZXNDaGFuZ2UgPT4gcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGNvbnN0IGFsbE5vblJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIHJlc0NoYW5nZSA9PiAhcmVzQ2hhbmdlLmlzUmVtb3ZhbCk7XG4gIGZvciAoY29uc3QgW2xvZ0lkLCBub25SZW1vdmFsQ2hhbmdlXSBvZiBPYmplY3QuZW50cmllcyhhbGxOb25SZW1vdmFsQ2hhbmdlcykpIHtcbiAgICBpZiAobm9uUmVtb3ZhbENoYW5nZS5pc0FkZGl0aW9uKSB7XG4gICAgICBjb25zdCBhZGRDaGFuZ2UgPSBub25SZW1vdmFsQ2hhbmdlO1xuICAgICAgLy8gc2VhcmNoIGZvciBhbiBpZGVudGljYWwgcmVtb3ZhbCBjaGFuZ2VcbiAgICAgIGNvbnN0IGlkZW50aWNhbFJlbW92YWxDaGFuZ2UgPSBPYmplY3QuZW50cmllcyhhbGxSZW1vdmFsQ2hhbmdlcykuZmluZCgoW18sIHJlbUNoYW5nZV0pID0+IHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXNBcmVGb3JTYW1lUmVzb3VyY2UocmVtQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgICAvLyBpZiB3ZSBmb3VuZCBvbmUsIHRoZW4gdGhpcyBtZWFucyB0aGlzIGlzIGEgcmVuYW1lIGNoYW5nZVxuICAgICAgaWYgKGlkZW50aWNhbFJlbW92YWxDaGFuZ2UpIHtcbiAgICAgICAgY29uc3QgW3JlbW92ZWRMb2dJZCwgcmVtb3ZlZFJlc291cmNlQ2hhbmdlXSA9IGlkZW50aWNhbFJlbW92YWxDaGFuZ2U7XG4gICAgICAgIGFsbE5vblJlbW92YWxDaGFuZ2VzW2xvZ0lkXSA9IG1ha2VSZW5hbWVEaWZmZXJlbmNlKHJlbW92ZWRSZXNvdXJjZUNoYW5nZSwgYWRkQ2hhbmdlKTtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSByZW1vdmFsIGNoYW5nZSB0aGF0IGZvcm1zIHRoZSByZW5hbWUgcGFpclxuICAgICAgICBkZWxldGUgYWxsUmVtb3ZhbENoYW5nZXNbcmVtb3ZlZExvZ0lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBhcmUgYWxsIG9mIHRoZSByZW1haW5pbmcgcmVtb3ZhbCBjaGFuZ2VzLFxuICAvLyBwbHVzIGFsbCBvZiB0aGUgbm9uLXJlbW92YWwgY2hhbmdlc1xuICAvLyAod2Ugc2F2ZWQgdGhlIHJlbmFtZSBjaGFuZ2VzIGluIHRoYXQgb2JqZWN0IGFscmVhZHkpXG4gIHJldHVybiB7XG4gICAgLi4uYWxsUmVtb3ZhbENoYW5nZXMsXG4gICAgLi4uYWxsTm9uUmVtb3ZhbENoYW5nZXMsXG4gIH07XG59XG5cbi8qKiBGaWx0ZXJzIGFuIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIGNhbGxiYWNrIHJldHVybnMgJ3RydWUnIGZvciB0aGUgZ2l2ZW4gdmFsdWUgaW4gdGhlIG9iamVjdC4gKi9cbmZ1bmN0aW9uIGZpbHRlckRpY3Q8VD4oZGljdDogeyBba2V5OiBzdHJpbmddOiBUIH0sIGZ1bmM6ICh0OiBUKSA9PiBib29sZWFuKTogeyBba2V5OiBzdHJpbmddOiBUIH0ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGljdCkucmVkdWNlKChhY2MsIFtrZXksIHRdKSA9PiB7XG4gICAgaWYgKGZ1bmModCkpIHtcbiAgICAgIGFjY1trZXldID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30gYXMgeyBba2V5OiBzdHJpbmddOiBUIH0pO1xufVxuXG4vKiogRmluZHMgYW55IGhvdHN3YXBwYWJsZSBjaGFuZ2VzIGluIGFsbCBuZXN0ZWQgc3RhY2tzLiAqL1xuYXN5bmMgZnVuY3Rpb24gZmluZE5lc3RlZEhvdHN3YXBwYWJsZUNoYW5nZXMoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLFxuICBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgbmVzdGVkU3RhY2tUZW1wbGF0ZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tUZW1wbGF0ZXMgfSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4gIGhvdHN3YXBQcm9wZXJ0eU92ZXJyaWRlczogSG90c3dhcFByb3BlcnR5T3ZlcnJpZGVzLFxuKTogUHJvbWlzZTxDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzPiB7XG4gIGNvbnN0IG5lc3RlZFN0YWNrID0gbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXTtcbiAgaWYgKCFuZXN0ZWRTdGFjay5waHlzaWNhbE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlQ2hhbmdlczogW10sXG4gICAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBbe1xuICAgICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgICBsb2dpY2FsSWQsXG4gICAgICAgIHJlYXNvbjogYHBoeXNpY2FsIG5hbWUgZm9yIEFXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrICcke2xvZ2ljYWxJZH0nIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBDbG91ZEZvcm1hdGlvbiwgc28gdGhpcyBpcyBhIG5ld2x5IGNyZWF0ZWQgbmVzdGVkIHN0YWNrIGFuZCBjYW5ub3QgYmUgaG90c3dhcHBlZGAsXG4gICAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICAgIHJlc291cmNlVHlwZTogJ0FXUzo6Q2xvdWRGb3JtYXRpb246OlN0YWNrJyxcbiAgICAgIH1dLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBldmFsdWF0ZU5lc3RlZENmblRlbXBsYXRlID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5jcmVhdGVOZXN0ZWRFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUoXG4gICAgbmVzdGVkU3RhY2sucGh5c2ljYWxOYW1lLCBuZXN0ZWRTdGFjay5nZW5lcmF0ZWRUZW1wbGF0ZSwgY2hhbmdlLm5ld1ZhbHVlPy5Qcm9wZXJ0aWVzPy5QYXJhbWV0ZXJzLFxuICApO1xuXG4gIGNvbnN0IG5lc3RlZERpZmYgPSBjZm5fZGlmZi5mdWxsRGlmZihcbiAgICBuZXN0ZWRTdGFja1RlbXBsYXRlc1tsb2dpY2FsSWRdLmRlcGxveWVkVGVtcGxhdGUsIG5lc3RlZFN0YWNrVGVtcGxhdGVzW2xvZ2ljYWxJZF0uZ2VuZXJhdGVkVGVtcGxhdGUsXG4gICk7XG5cbiAgcmV0dXJuIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICAgIG5lc3RlZERpZmYsXG4gICAgZXZhbHVhdGVOZXN0ZWRDZm5UZW1wbGF0ZSxcbiAgICBzZGssXG4gICAgbmVzdGVkU3RhY2tUZW1wbGF0ZXNbbG9naWNhbElkXS5uZXN0ZWRTdGFja1RlbXBsYXRlcyxcbiAgICBob3Rzd2FwUHJvcGVydHlPdmVycmlkZXMpO1xufVxuXG4vKiogUmV0dXJucyAndHJ1ZScgaWYgYSBwYWlyIG9mIGNoYW5nZXMgaXMgZm9yIHRoZSBzYW1lIHJlc291cmNlLiAqL1xuZnVuY3Rpb24gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShvbGRDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSwgbmV3Q2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIG9sZENoYW5nZS5vbGRSZXNvdXJjZVR5cGUgPT09IG5ld0NoYW5nZS5uZXdSZXNvdXJjZVR5cGUgJiZcbiAgICAvLyB0aGlzIGlzbid0IGdyZWF0LCBidXQgSSBkb24ndCB3YW50IHRvIGJyaW5nIGluIHNvbWV0aGluZyBsaWtlIHVuZGVyc2NvcmUganVzdCBmb3IgdGhpcyBjb21wYXJpc29uXG4gICAgSlNPTi5zdHJpbmdpZnkob2xkQ2hhbmdlLm9sZFByb3BlcnRpZXMpID09PSBKU09OLnN0cmluZ2lmeShuZXdDaGFuZ2UubmV3UHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZW5hbWVEaWZmZXJlbmNlKFxuICByZW1DaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgYWRkQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4pOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2Uge1xuICByZXR1cm4gbmV3IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZShcbiAgICAvLyB3ZSBoYXZlIHRvIGZpbGwgaW4gdGhlIG9sZCB2YWx1ZSwgYmVjYXVzZSBvdGhlcndpc2UgdGhpcyB3aWxsIGJlIGNsYXNzaWZpZWQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZVxuICAgIHJlbUNoYW5nZS5vbGRWYWx1ZSxcbiAgICBhZGRDaGFuZ2UubmV3VmFsdWUsXG4gICAge1xuICAgICAgcmVzb3VyY2VUeXBlOiB7XG4gICAgICAgIG9sZFR5cGU6IHJlbUNoYW5nZS5vbGRSZXNvdXJjZVR5cGUsXG4gICAgICAgIG5ld1R5cGU6IGFkZENoYW5nZS5uZXdSZXNvdXJjZVR5cGUsXG4gICAgICB9LFxuICAgICAgcHJvcGVydHlEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLnByb3BlcnR5RGlmZnMsXG4gICAgICBvdGhlckRpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkub3RoZXJEaWZmcyxcbiAgICB9LFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlYCBpZiB0aGUgY2hhbmdlIGlzIGhvdHN3YXBwYWJsZVxuICogUmV0dXJucyBhbiBlbXB0eSBgSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIHRvIENESzo6TWV0YWRhdGFcbiAqIFJldHVybnMgYSBgTm9uSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBob3Rzd2FwcGFibGVcbiAqL1xuZnVuY3Rpb24gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsIGxvZ2ljYWxJZDogc3RyaW5nLFxuKTogSG90c3dhcHBhYmxlQ2hhbmdlIHwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlIHwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlIHtcbiAgLy8gYSByZXNvdXJjZSBoYXMgYmVlbiByZW1vdmVkIE9SIGEgcmVzb3VyY2UgaGFzIGJlZW4gYWRkZWQ7IHdlIGNhbid0IHNob3J0LWNpcmN1aXQgdGhhdCBjaGFuZ2VcbiAgaWYgKCFjaGFuZ2Uub2xkVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlIS5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBjcmVhdGVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfSBlbHNlIGlmICghY2hhbmdlLm5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5vbGRWYWx1ZSEuVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyB3YXMgZGVzdHJveWVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGEgcmVzb3VyY2UgaGFzIGhhZCBpdHMgdHlwZSBjaGFuZ2VkXG4gIGlmIChjaGFuZ2UubmV3VmFsdWU/LlR5cGUgIT09IGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWU/LlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgaGFkIGl0cyB0eXBlIGNoYW5nZWQgZnJvbSAnJHtjaGFuZ2Uub2xkVmFsdWU/LlR5cGV9JyB0byAnJHtjaGFuZ2UubmV3VmFsdWU/LlR5cGV9J2AsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9naWNhbElkLFxuICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgbmV3VmFsdWU6IGNoYW5nZS5uZXdWYWx1ZSxcbiAgICBwcm9wZXJ0eVVwZGF0ZXM6IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhzZGs6IElTREssIGhvdHN3YXBwYWJsZUNoYW5nZXM6IEhvdHN3YXBwYWJsZUNoYW5nZVtdKTogUHJvbWlzZTx2b2lkW10+IHtcbiAgaWYgKGhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIHByaW50KGBcXG4ke0lDT059IGhvdHN3YXBwaW5nIHJlc291cmNlczpgKTtcbiAgfVxuICBjb25zdCBsaW1pdCA9IHBMaW1pdCgxMCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbVxuICByZXR1cm4gUHJvbWlzZS5hbGwoaG90c3dhcHBhYmxlQ2hhbmdlcy5tYXAoaG90c3dhcE9wZXJhdGlvbiA9PiBsaW1pdCgoKSA9PiB7XG4gICAgcmV0dXJuIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkaywgaG90c3dhcE9wZXJhdGlvbik7XG4gIH0pKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkazogSVNESywgaG90c3dhcE9wZXJhdGlvbjogSG90c3dhcHBhYmxlQ2hhbmdlKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIG5vdGUgdGhlIHR5cGUgb2Ygc2VydmljZSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgaG90c3dhcHBlZCBpbiB0aGUgVXNlci1BZ2VudFxuICBjb25zdCBjdXN0b21Vc2VyQWdlbnQgPSBgY2RrLWhvdHN3YXAvc3VjY2Vzcy0ke2hvdHN3YXBPcGVyYXRpb24uc2VydmljZX1gO1xuICBzZGsuYXBwZW5kQ3VzdG9tVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG5cbiAgZm9yIChjb25zdCBuYW1lIG9mIGhvdHN3YXBPcGVyYXRpb24ucmVzb3VyY2VOYW1lcykge1xuICAgIHByaW50KGAgICAke0lDT059ICVzYCwgY2hhbGsuYm9sZChuYW1lKSk7XG4gIH1cblxuICAvLyBpZiB0aGUgU0RLIGNhbGwgZmFpbHMsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGJ5IHRoZSBTREtcbiAgLy8gYW5kIHdpbGwgcHJldmVudCB0aGUgZ3JlZW4gJ2hvdHN3YXBwZWQhJyB0ZXh0IGZyb20gYmVpbmcgZGlzcGxheWVkXG4gIGF3YWl0IGhvdHN3YXBPcGVyYXRpb24uYXBwbHkoc2RrKTtcblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgcHJpbnQoYCR7SUNPTn0gJXMgJXNgLCBjaGFsay5ib2xkKG5hbWUpLCBjaGFsay5ncmVlbignaG90c3dhcHBlZCEnKSk7XG4gIH1cblxuICBzZGsucmVtb3ZlQ3VzdG9tVXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudCk7XG59XG5cbmZ1bmN0aW9uIGxvZ05vbkhvdHN3YXBwYWJsZUNoYW5nZXMobm9uSG90c3dhcHBhYmxlQ2hhbmdlczogTm9uSG90c3dhcHBhYmxlQ2hhbmdlW10sIGhvdHN3YXBNb2RlOiBIb3Rzd2FwTW9kZSk6IHZvaWQge1xuICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqXG4gICAqIEVLUyBTZXJ2aWNlcyBjYW4gaGF2ZSBhIHRhc2sgZGVmaW5pdGlvbiB0aGF0IGRvZXNuJ3QgcmVmZXIgdG8gdGhlIHRhc2sgZGVmaW5pdGlvbiBiZWluZyB1cGRhdGVkLlxuICAgKiBXZSBoYXZlIHRvIGxvZyB0aGlzIGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UgdG8gdGhlIHRhc2sgZGVmaW5pdGlvbiwgYnV0IHdoZW4gd2UgZG8sXG4gICAqIHdlIHdpbmQgdXAgaG90c3dhcHBpbmcgdGhlIHRhc2sgZGVmaW5pdGlvbiBhbmQgbG9nZ2luZyBpdCBhcyBhIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGlzIGxvZ2ljIHByZXZlbnRzIHVzIGZyb20gbG9nZ2luZyB0aGF0IGNoYW5nZSBhcyBub24taG90c3dhcHBhYmxlIHdoZW4gd2UgaG90c3dhcCBpdC5cbiAgICovXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gSG90c3dhcE1vZGUuSE9UU1dBUF9PTkxZKSB7XG4gICAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlcyA9IG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMuZmlsdGVyKChjaGFuZ2UpID0+IGNoYW5nZS5ob3Rzd2FwT25seVZpc2libGUgPT09IHRydWUpO1xuXG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gSG90c3dhcE1vZGUuSE9UU1dBUF9PTkxZKSB7XG4gICAgcHJpbnQoJ1xcbiVzICVzJywgY2hhbGsucmVkKCfimqDvuI8nKSwgY2hhbGsucmVkKCdUaGUgZm9sbG93aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyB3ZXJlIGZvdW5kLiBUbyByZWNvbmNpbGUgdGhlc2UgdXNpbmcgQ2xvdWRGb3JtYXRpb24sIHNwZWNpZnkgLS1ob3Rzd2FwLWZhbGxiYWNrJykpO1xuICB9IGVsc2Uge1xuICAgIHByaW50KCdcXG4lcyAlcycsIGNoYWxrLnJlZCgn4pqg77iPJyksIGNoYWxrLnJlZCgnVGhlIGZvbGxvd2luZyBub24taG90c3dhcHBhYmxlIGNoYW5nZXMgd2VyZSBmb3VuZDonKSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzKSB7XG4gICAgY2hhbmdlLnJlamVjdGVkQ2hhbmdlcy5sZW5ndGggPiAwID9cbiAgICAgIHByaW50KCcgICAgbG9naWNhbElEOiAlcywgdHlwZTogJXMsIHJlamVjdGVkIGNoYW5nZXM6ICVzLCByZWFzb246ICVzJywgY2hhbGsuYm9sZChjaGFuZ2UubG9naWNhbElkKSwgY2hhbGsuYm9sZChjaGFuZ2UucmVzb3VyY2VUeXBlKSwgY2hhbGsuYm9sZChjaGFuZ2UucmVqZWN0ZWRDaGFuZ2VzKSwgY2hhbGsucmVkKGNoYW5nZS5yZWFzb24pKSA6XG4gICAgICBwcmludCgnICAgIGxvZ2ljYWxJRDogJXMsIHR5cGU6ICVzLCByZWFzb246ICVzJywgY2hhbGsuYm9sZChjaGFuZ2UubG9naWNhbElkKSwgY2hhbGsuYm9sZChjaGFuZ2UucmVzb3VyY2VUeXBlKSwgY2hhbGsucmVkKGNoYW5nZS5yZWFzb24pKTtcbiAgfVxuXG4gIHByaW50KCcnKTsgLy8gbmV3bGluZVxufVxuIl19