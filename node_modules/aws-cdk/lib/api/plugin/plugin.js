"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginHost = exports.TESTING = void 0;
exports.markTesting = markTesting;
const util_1 = require("util");
const chalk = require("chalk");
const _env_1 = require("./_env");
const context_provider_plugin_1 = require("./context-provider-plugin");
exports.TESTING = false;
function markTesting() {
    exports.TESTING = true;
}
/**
 * A utility to manage plug-ins.
 *
 */
class PluginHost {
    constructor() {
        /**
         * Access the currently registered CredentialProviderSources. New sources can
         * be registered using the +registerCredentialProviderSource+ method.
         */
        this.credentialProviderSources = new Array();
        this.contextProviderPlugins = {};
        if (!exports.TESTING && PluginHost.instance && PluginHost.instance !== this) {
            throw new Error('New instances of PluginHost must not be built. Use PluginHost.instance instead!');
        }
    }
    /**
     * Loads a plug-in into this PluginHost.
     *
     * @param moduleSpec the specification (path or name) of the plug-in module to be loaded.
     */
    load(moduleSpec) {
        try {
            /* eslint-disable @typescript-eslint/no-require-imports */
            const plugin = require(moduleSpec);
            /* eslint-enable */
            if (!isPlugin(plugin)) {
                (0, _env_1.error)(`Module ${chalk.green(moduleSpec)} is not a valid plug-in, or has an unsupported version.`);
                throw new Error(`Module ${moduleSpec} does not define a valid plug-in.`);
            }
            if (plugin.init) {
                plugin.init(this);
            }
        }
        catch (e) {
            (0, _env_1.error)(`Unable to load ${chalk.green(moduleSpec)}: ${e.stack}`);
            throw new Error(`Unable to load plug-in: ${moduleSpec}: ${e}`);
        }
        function isPlugin(x) {
            return x != null && x.version === '1';
        }
    }
    /**
     * Allows plug-ins to register new CredentialProviderSources.
     *
     * @param source a new CredentialProviderSource to register.
     */
    registerCredentialProviderSource(source) {
        // Forward to the right credentials-related plugin host
        this.credentialProviderSources.push(source);
    }
    /**
     * (EXPERIMENTAL) Allow plugins to register context providers
     *
     * Context providers are objects with the following method:
     *
     * ```ts
     *   getValue(args: {[key: string]: any}): Promise<any>;
     * ```
     *
     * Currently, they cannot reuse the CDK's authentication mechanisms, so they
     * must be prepared to either not make AWS calls or use their own source of
     * AWS credentials.
     *
     * This feature is experimental, and only intended to be used internally at Amazon
     * as a trial.
     *
     * After registering with 'my-plugin-name', the provider must be addressed as follows:
     *
     * ```ts
     * const value = ContextProvider.getValue(this, {
     *   providerName: 'plugin',
     *   props: {
     *     pluginName: 'my-plugin-name',
     *     myParameter1: 'xyz',
     *   },
     *   includeEnvironment: true | false,
     *   dummyValue: 'what-to-return-on-the-first-pass',
     * })
     * ```
     *
     * @experimental
     */
    registerContextProviderAlpha(pluginProviderName, provider) {
        if (!(0, context_provider_plugin_1.isContextProviderPlugin)(provider)) {
            throw new Error(`Object you gave me does not look like a ContextProviderPlugin: ${(0, util_1.inspect)(provider)}`);
        }
        this.contextProviderPlugins[pluginProviderName] = provider;
    }
}
exports.PluginHost = PluginHost;
PluginHost.instance = new PluginHost();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQVNBLGtDQUVDO0FBWEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUUvQixpQ0FBK0I7QUFDL0IsdUVBQTJGO0FBR2hGLFFBQUEsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUUzQixTQUFnQixXQUFXO0lBQ3pCLGVBQU8sR0FBRyxJQUFJLENBQUM7QUFDakIsQ0FBQztBQWlDRDs7O0dBR0c7QUFDSCxNQUFhLFVBQVU7SUFXckI7UUFSQTs7O1dBR0c7UUFDYSw4QkFBeUIsR0FBRyxJQUFJLEtBQUssRUFBNEIsQ0FBQztRQUVsRSwyQkFBc0IsR0FBMEMsRUFBRSxDQUFDO1FBR2pGLElBQUksQ0FBQyxlQUFPLElBQUksVUFBVSxDQUFDLFFBQVEsSUFBSSxVQUFVLENBQUMsUUFBUSxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3BFLE1BQU0sSUFBSSxLQUFLLENBQUMsaUZBQWlGLENBQUMsQ0FBQztRQUNyRyxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxJQUFJLENBQUMsVUFBa0I7UUFDNUIsSUFBSSxDQUFDO1lBQ0gsMERBQTBEO1lBQzFELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNuQyxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO2dCQUN0QixJQUFBLFlBQUssRUFBQyxVQUFVLEtBQUssQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLHlEQUF5RCxDQUFDLENBQUM7Z0JBQ2xHLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxVQUFVLG1DQUFtQyxDQUFDLENBQUM7WUFDM0UsQ0FBQztZQUNELElBQUksTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFBQyxDQUFDO1FBQ3pDLENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLElBQUEsWUFBSyxFQUFDLGtCQUFrQixLQUFLLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1lBQy9ELE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLFVBQVUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pFLENBQUM7UUFFRCxTQUFTLFFBQVEsQ0FBQyxDQUFNO1lBQ3RCLE9BQU8sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLEdBQUcsQ0FBQztRQUN4QyxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxnQ0FBZ0MsQ0FBQyxNQUFnQztRQUN0RSx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLHlCQUF5QixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ErQkc7SUFDSSw0QkFBNEIsQ0FBQyxrQkFBMEIsRUFBRSxRQUErQjtRQUM3RixJQUFJLENBQUMsSUFBQSxpREFBdUIsRUFBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0VBQWtFLElBQUEsY0FBTyxFQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RyxDQUFDO1FBQ0QsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGtCQUFrQixDQUFDLEdBQUcsUUFBUSxDQUFDO0lBQzdELENBQUM7O0FBekZILGdDQTBGQztBQXpGZSxtQkFBUSxHQUFHLElBQUksVUFBVSxFQUFFLEFBQW5CLENBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuXG5pbXBvcnQgeyBlcnJvciB9IGZyb20gJy4vX2Vudic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4sIGlzQ29udGV4dFByb3ZpZGVyUGx1Z2luIH0gZnJvbSAnLi9jb250ZXh0LXByb3ZpZGVyLXBsdWdpbic7XG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UgfSBmcm9tICcuL2NyZWRlbnRpYWwtcHJvdmlkZXItc291cmNlJztcblxuZXhwb3J0IGxldCBURVNUSU5HID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrVGVzdGluZygpIHtcbiAgVEVTVElORyA9IHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2ljIGNvbnRyYWN0IGZvciBwbHVnLWlucyB0byBhZGhlcmUgdG86OlxuICpcbiAqICAgaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5Ib3N0IH0gZnJvbSAnYXdzLWNkayc7XG4gKiAgIGltcG9ydCB7IEN1c3RvbUNyZWRlbnRpYWxQcm92aWRlclNvdXJjZSB9IGZyb20gJy4vY3VzdG9tLWNyZWRlbnRpYWwtcHJvdmlkZXItc291cmNlJztcbiAqXG4gKiAgIGV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvb0NES1BsdWdJbiBpbXBsZW1lbnRzIFBsdWdpbkhvc3Qge1xuICogICAgIHB1YmxpYyByZWFkb25seSB2ZXJzaW9uID0gJzEnO1xuICpcbiAqICAgICBwdWJsaWMgaW5pdChob3N0OiBQbHVnaW5Ib3N0KSB7XG4gKiAgICAgaG9zdC5yZWdpc3RlckNyZWRlbnRpYWxQcm92aWRlclNvdXJjZShuZXcgQ3VzdG9tQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKCkpO1xuICogICAgIH1cbiAqICAgfVxuICpcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQbHVnaW4ge1xuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHBsdWctaW4gaW50ZXJmYWNlIHVzZWQgYnkgdGhlIHBsdWctaW4uIFRoaXMgd2lsbCBiZSB1c2VkIGJ5XG4gICAqIHRoZSBwbHVnLWluIGhvc3QgdG8gaGFuZGxlIHZlcnNpb24gY2hhbmdlcy5cbiAgICovXG4gIHZlcnNpb246ICcxJztcblxuICAvKipcbiAgICogV2hlbiBkZWZpbmVkLCB0aGlzIGZ1bmN0aW9uIGlzIGludm9rZWQgcmlnaHQgYWZ0ZXIgdGhlIHBsdWctaW4gaGFzIGJlZW4gbG9hZGVkLFxuICAgKiBzbyB0aGF0IHRoZSBwbHVnLWluIGlzIGFibGUgdG8gaW5pdGlhbGl6ZSBpdHNlbGYuIEl0IG1heSBjYWxsIG1ldGhvZHMgb2YgdGhlXG4gICAqIGBgUGx1Z2luSG9zdGBgIGluc3RhbmNlIGl0IHJlY2VpdmVzIHRvIHJlZ2lzdGVyIG5ldyBgYENyZWRlbnRpYWxQcm92aWRlclNvdXJjZWBgXG4gICAqIGluc3RhbmNlcy5cbiAgICovXG4gIGluaXQ/OiAoaG9zdDogUGx1Z2luSG9zdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBBIHV0aWxpdHkgdG8gbWFuYWdlIHBsdWctaW5zLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBsdWdpbkhvc3Qge1xuICBwdWJsaWMgc3RhdGljIGluc3RhbmNlID0gbmV3IFBsdWdpbkhvc3QoKTtcblxuICAvKipcbiAgICogQWNjZXNzIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLiBOZXcgc291cmNlcyBjYW5cbiAgICogYmUgcmVnaXN0ZXJlZCB1c2luZyB0aGUgK3JlZ2lzdGVyQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlKyBtZXRob2QuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY3JlZGVudGlhbFByb3ZpZGVyU291cmNlcyA9IG5ldyBBcnJheTxDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2U+KCk7XG5cbiAgcHVibGljIHJlYWRvbmx5IGNvbnRleHRQcm92aWRlclBsdWdpbnM6IFJlY29yZDxzdHJpbmcsIENvbnRleHRQcm92aWRlclBsdWdpbj4gPSB7fTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAoIVRFU1RJTkcgJiYgUGx1Z2luSG9zdC5pbnN0YW5jZSAmJiBQbHVnaW5Ib3N0Lmluc3RhbmNlICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldyBpbnN0YW5jZXMgb2YgUGx1Z2luSG9zdCBtdXN0IG5vdCBiZSBidWlsdC4gVXNlIFBsdWdpbkhvc3QuaW5zdGFuY2UgaW5zdGVhZCEnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBwbHVnLWluIGludG8gdGhpcyBQbHVnaW5Ib3N0LlxuICAgKlxuICAgKiBAcGFyYW0gbW9kdWxlU3BlYyB0aGUgc3BlY2lmaWNhdGlvbiAocGF0aCBvciBuYW1lKSBvZiB0aGUgcGx1Zy1pbiBtb2R1bGUgdG8gYmUgbG9hZGVkLlxuICAgKi9cbiAgcHVibGljIGxvYWQobW9kdWxlU3BlYzogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbiAgICAgIGNvbnN0IHBsdWdpbiA9IHJlcXVpcmUobW9kdWxlU3BlYyk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICBpZiAoIWlzUGx1Z2luKHBsdWdpbikpIHtcbiAgICAgICAgZXJyb3IoYE1vZHVsZSAke2NoYWxrLmdyZWVuKG1vZHVsZVNwZWMpfSBpcyBub3QgYSB2YWxpZCBwbHVnLWluLCBvciBoYXMgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbi5gKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNb2R1bGUgJHttb2R1bGVTcGVjfSBkb2VzIG5vdCBkZWZpbmUgYSB2YWxpZCBwbHVnLWluLmApO1xuICAgICAgfVxuICAgICAgaWYgKHBsdWdpbi5pbml0KSB7IHBsdWdpbi5pbml0KHRoaXMpOyB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBlcnJvcihgVW5hYmxlIHRvIGxvYWQgJHtjaGFsay5ncmVlbihtb2R1bGVTcGVjKX06ICR7ZS5zdGFja31gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgcGx1Zy1pbjogJHttb2R1bGVTcGVjfTogJHtlfWApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUGx1Z2luKHg6IGFueSk6IHggaXMgUGx1Z2luIHtcbiAgICAgIHJldHVybiB4ICE9IG51bGwgJiYgeC52ZXJzaW9uID09PSAnMSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBwbHVnLWlucyB0byByZWdpc3RlciBuZXcgQ3JlZGVudGlhbFByb3ZpZGVyU291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZSBhIG5ldyBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UgdG8gcmVnaXN0ZXIuXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2Uoc291cmNlOiBDcmVkZW50aWFsUHJvdmlkZXJTb3VyY2UpIHtcbiAgICAvLyBGb3J3YXJkIHRvIHRoZSByaWdodCBjcmVkZW50aWFscy1yZWxhdGVkIHBsdWdpbiBob3N0XG4gICAgdGhpcy5jcmVkZW50aWFsUHJvdmlkZXJTb3VyY2VzLnB1c2goc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoRVhQRVJJTUVOVEFMKSBBbGxvdyBwbHVnaW5zIHRvIHJlZ2lzdGVyIGNvbnRleHQgcHJvdmlkZXJzXG4gICAqXG4gICAqIENvbnRleHQgcHJvdmlkZXJzIGFyZSBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBtZXRob2Q6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqICAgZ2V0VmFsdWUoYXJnczoge1trZXk6IHN0cmluZ106IGFueX0pOiBQcm9taXNlPGFueT47XG4gICAqIGBgYFxuICAgKlxuICAgKiBDdXJyZW50bHksIHRoZXkgY2Fubm90IHJldXNlIHRoZSBDREsncyBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc21zLCBzbyB0aGV5XG4gICAqIG11c3QgYmUgcHJlcGFyZWQgdG8gZWl0aGVyIG5vdCBtYWtlIEFXUyBjYWxscyBvciB1c2UgdGhlaXIgb3duIHNvdXJjZSBvZlxuICAgKiBBV1MgY3JlZGVudGlhbHMuXG4gICAqXG4gICAqIFRoaXMgZmVhdHVyZSBpcyBleHBlcmltZW50YWwsIGFuZCBvbmx5IGludGVuZGVkIHRvIGJlIHVzZWQgaW50ZXJuYWxseSBhdCBBbWF6b25cbiAgICogYXMgYSB0cmlhbC5cbiAgICpcbiAgICogQWZ0ZXIgcmVnaXN0ZXJpbmcgd2l0aCAnbXktcGx1Z2luLW5hbWUnLCB0aGUgcHJvdmlkZXIgbXVzdCBiZSBhZGRyZXNzZWQgYXMgZm9sbG93czpcbiAgICpcbiAgICogYGBgdHNcbiAgICogY29uc3QgdmFsdWUgPSBDb250ZXh0UHJvdmlkZXIuZ2V0VmFsdWUodGhpcywge1xuICAgKiAgIHByb3ZpZGVyTmFtZTogJ3BsdWdpbicsXG4gICAqICAgcHJvcHM6IHtcbiAgICogICAgIHBsdWdpbk5hbWU6ICdteS1wbHVnaW4tbmFtZScsXG4gICAqICAgICBteVBhcmFtZXRlcjE6ICd4eXonLFxuICAgKiAgIH0sXG4gICAqICAgaW5jbHVkZUVudmlyb25tZW50OiB0cnVlIHwgZmFsc2UsXG4gICAqICAgZHVtbXlWYWx1ZTogJ3doYXQtdG8tcmV0dXJuLW9uLXRoZS1maXJzdC1wYXNzJyxcbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlckNvbnRleHRQcm92aWRlckFscGhhKHBsdWdpblByb3ZpZGVyTmFtZTogc3RyaW5nLCBwcm92aWRlcjogQ29udGV4dFByb3ZpZGVyUGx1Z2luKSB7XG4gICAgaWYgKCFpc0NvbnRleHRQcm92aWRlclBsdWdpbihwcm92aWRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IHlvdSBnYXZlIG1lIGRvZXMgbm90IGxvb2sgbGlrZSBhIENvbnRleHRQcm92aWRlclBsdWdpbjogJHtpbnNwZWN0KHByb3ZpZGVyKX1gKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0UHJvdmlkZXJQbHVnaW5zW3BsdWdpblByb3ZpZGVyTmFtZV0gPSBwcm92aWRlcjtcbiAgfVxufVxuIl19